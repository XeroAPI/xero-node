/**
 * Xero Accounting API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 6.2.0
 * Contact: api@xero.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import http = require('http');
import fs = require('fs');

/* tslint:disable:no-unused-locals */
import { Account } from '../model/accounting/account';
import { Accounts } from '../model/accounting/accounts';
import { Actions } from '../model/accounting/actions';
import { Allocation } from '../model/accounting/allocation';
import { Allocations } from '../model/accounting/allocations';
import { Attachments } from '../model/accounting/attachments';
import { BankTransactions } from '../model/accounting/bankTransactions';
import { BankTransfers } from '../model/accounting/bankTransfers';
import { BatchPaymentDelete } from '../model/accounting/batchPaymentDelete';
import { BatchPaymentDeleteByUrlParam } from '../model/accounting/batchPaymentDeleteByUrlParam';
import { BatchPayments } from '../model/accounting/batchPayments';
import { BrandingThemes } from '../model/accounting/brandingThemes';
import { Budgets } from '../model/accounting/budgets';
import { CISOrgSettings } from '../model/accounting/cISOrgSettings';
import { CISSettings } from '../model/accounting/cISSettings';
import { ContactGroups } from '../model/accounting/contactGroups';
import { Contacts } from '../model/accounting/contacts';
import { CreditNotes } from '../model/accounting/creditNotes';
import { Currencies } from '../model/accounting/currencies';
import { Currency } from '../model/accounting/currency';
import { Employees } from '../model/accounting/employees';
import { ExpenseClaims } from '../model/accounting/expenseClaims';
import { HistoryRecords } from '../model/accounting/historyRecords';
import { ImportSummaryObject } from '../model/accounting/importSummaryObject';
import { InvoiceReminders } from '../model/accounting/invoiceReminders';
import { Invoices } from '../model/accounting/invoices';
import { Items } from '../model/accounting/items';
import { Journals } from '../model/accounting/journals';
import { LinkedTransaction } from '../model/accounting/linkedTransaction';
import { LinkedTransactions } from '../model/accounting/linkedTransactions';
import { ManualJournals } from '../model/accounting/manualJournals';
import { OnlineInvoices } from '../model/accounting/onlineInvoices';
import { Organisations } from '../model/accounting/organisations';
import { Overpayments } from '../model/accounting/overpayments';
import { Payment } from '../model/accounting/payment';
import { PaymentDelete } from '../model/accounting/paymentDelete';
import { PaymentServices } from '../model/accounting/paymentServices';
import { Payments } from '../model/accounting/payments';
import { Prepayments } from '../model/accounting/prepayments';
import { PurchaseOrders } from '../model/accounting/purchaseOrders';
import { Quotes } from '../model/accounting/quotes';
import { Receipts } from '../model/accounting/receipts';
import { RepeatingInvoices } from '../model/accounting/repeatingInvoices';
import { ReportWithRows } from '../model/accounting/reportWithRows';
import { Reports } from '../model/accounting/reports';
import { RequestEmpty } from '../model/accounting/requestEmpty';
import { Setup } from '../model/accounting/setup';
import { TaxRates } from '../model/accounting/taxRates';
import { TrackingCategories } from '../model/accounting/trackingCategories';
import { TrackingCategory } from '../model/accounting/trackingCategory';
import { TrackingOption } from '../model/accounting/trackingOption';
import { TrackingOptions } from '../model/accounting/trackingOptions';
import { Users } from '../model/accounting/users';

import { ObjectSerializer, Authentication, VoidAuth } from '../model/accounting/models';
import { ApiError } from '../../model/ApiError';
import axios, { AxiosRequestConfig, AxiosResponse } from 'axios';
import { Readable } from "stream";
import { OAuth } from '../model/accounting/models';

let defaultBasePath = 'https://api.xero.com/api.xro/2.0';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum AccountingApiApiKeys {
}

export class AccountingApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {'user-agent': 'xero-node-9.5.0'};
    protected _useQuerystring : boolean = false;
    protected binaryHeaders : any = {};

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
        'OAuth2': new OAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: AccountingApiApiKeys, value: string) {
        (this.authentications as any)[AccountingApiApiKeys[key]].apiKey = value;
    }

    set accessToken(token: string) {
        this.authentications.OAuth2.accessToken = token;
    }

    /**
     * 
     * @summary Creates a new chart of accounts
     * @param xeroTenantId Xero identifier for Tenant
     * @param account Account object in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createAccount (xeroTenantId: string, account: Account, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Accounts;  }> {
        const localVarPath = this.basePath + '/Accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createAccount.');
        }

        // verify required parameter 'account' is not null or undefined
        if (account === null || account === undefined) {
            throw new Error('Required parameter account was null or undefined when calling createAccount.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(account, "Account"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Accounts;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Accounts");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates an attachment on a specific account
     * @param xeroTenantId Xero identifier for Tenant
     * @param accountID Unique identifier for Account object
     * @param fileName Name of the attachment
     * @param body Byte array of file in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createAccountAttachmentByFileName (xeroTenantId: string, accountID: string, fileName: string, body: fs.ReadStream | Readable | Buffer , idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/Accounts/{AccountID}/Attachments/{FileName}'
            .replace('{' + 'AccountID' + '}', encodeURIComponent(String(accountID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createAccountAttachmentByFileName.');
        }

        // verify required parameter 'accountID' is not null or undefined
        if (accountID === null || accountID === undefined) {
            throw new Error('Required parameter accountID was null or undefined when calling createAccountAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling createAccountAttachmentByFileName.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createAccountAttachmentByFileName.');
        }
        this.binaryHeaders = {'Accept': 'application/json'};
        (<any>Object).assign(localVarHeaderParams, this.binaryHeaders);
        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(body, "string"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
        }).then(() => {
            // Reads file stream as chunks so we can put it in body of request.
            // This collects the whole file into memory, which is why we do it _after_ authentication.
            return new Promise<any[]>((resolve, reject) => {
               	let bodyStream;
                bodyStream = Buffer.isBuffer(body) ? Readable.from(body) : body
                const fileContents: any[] = [];
                bodyStream.on('data', (chunk) => {
                    fileContents.push(chunk);
                });
                bodyStream.on('end', () => {
                    resolve(fileContents);
                });
                bodyStream.on('error', (err) => {
                    reject(err);
                })
            });
        }).then((fileContents) => {
            const file = Buffer.concat(fileContents);
            localVarRequestOptions.data = file;
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates an attachment for a specific bank transaction by filename
     * @param xeroTenantId Xero identifier for Tenant
     * @param bankTransactionID Xero generated unique identifier for a bank transaction
     * @param fileName Name of the attachment
     * @param body Byte array of file in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createBankTransactionAttachmentByFileName (xeroTenantId: string, bankTransactionID: string, fileName: string, body: fs.ReadStream | Readable | Buffer , idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/BankTransactions/{BankTransactionID}/Attachments/{FileName}'
            .replace('{' + 'BankTransactionID' + '}', encodeURIComponent(String(bankTransactionID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createBankTransactionAttachmentByFileName.');
        }

        // verify required parameter 'bankTransactionID' is not null or undefined
        if (bankTransactionID === null || bankTransactionID === undefined) {
            throw new Error('Required parameter bankTransactionID was null or undefined when calling createBankTransactionAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling createBankTransactionAttachmentByFileName.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createBankTransactionAttachmentByFileName.');
        }
        this.binaryHeaders = {'Accept': 'application/json'};
        (<any>Object).assign(localVarHeaderParams, this.binaryHeaders);
        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(body, "string"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
        }).then(() => {
            // Reads file stream as chunks so we can put it in body of request.
            // This collects the whole file into memory, which is why we do it _after_ authentication.
            return new Promise<any[]>((resolve, reject) => {
               	let bodyStream;
                bodyStream = Buffer.isBuffer(body) ? Readable.from(body) : body
                const fileContents: any[] = [];
                bodyStream.on('data', (chunk) => {
                    fileContents.push(chunk);
                });
                bodyStream.on('end', () => {
                    resolve(fileContents);
                });
                bodyStream.on('error', (err) => {
                    reject(err);
                })
            });
        }).then((fileContents) => {
            const file = Buffer.concat(fileContents);
            localVarRequestOptions.data = file;
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a history record for a specific bank transactions
     * @param xeroTenantId Xero identifier for Tenant
     * @param bankTransactionID Xero generated unique identifier for a bank transaction
     * @param historyRecords HistoryRecords containing an array of HistoryRecord objects in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createBankTransactionHistoryRecord (xeroTenantId: string, bankTransactionID: string, historyRecords: HistoryRecords, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/BankTransactions/{BankTransactionID}/History'
            .replace('{' + 'BankTransactionID' + '}', encodeURIComponent(String(bankTransactionID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createBankTransactionHistoryRecord.');
        }

        // verify required parameter 'bankTransactionID' is not null or undefined
        if (bankTransactionID === null || bankTransactionID === undefined) {
            throw new Error('Required parameter bankTransactionID was null or undefined when calling createBankTransactionHistoryRecord.');
        }

        // verify required parameter 'historyRecords' is not null or undefined
        if (historyRecords === null || historyRecords === undefined) {
            throw new Error('Required parameter historyRecords was null or undefined when calling createBankTransactionHistoryRecord.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(historyRecords, "HistoryRecords"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates one or more spent or received money transaction
     * @param xeroTenantId Xero identifier for Tenant
     * @param bankTransactions BankTransactions with an array of BankTransaction objects in body of request
     * @param summarizeErrors If false return 200 OK and mix of successfully created objects and any with validation errors
     * @param unitdp e.g. unitdp&#x3D;4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createBankTransactions (xeroTenantId: string, bankTransactions: BankTransactions, summarizeErrors?: boolean, unitdp?: number, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: BankTransactions;  }> {
        const localVarPath = this.basePath + '/BankTransactions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createBankTransactions.');
        }

        // verify required parameter 'bankTransactions' is not null or undefined
        if (bankTransactions === null || bankTransactions === undefined) {
            throw new Error('Required parameter bankTransactions was null or undefined when calling createBankTransactions.');
        }

        if (summarizeErrors !== undefined) {
            localVarQueryParameters['summarizeErrors'] = ObjectSerializer.serialize(summarizeErrors, "boolean");
        }

        if (unitdp !== undefined) {
            localVarQueryParameters['unitdp'] = ObjectSerializer.serialize(unitdp, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(bankTransactions, "BankTransactions"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: BankTransactions;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "BankTransactions");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a bank transfer
     * @param xeroTenantId Xero identifier for Tenant
     * @param bankTransfers BankTransfers with array of BankTransfer objects in request body
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createBankTransfer (xeroTenantId: string, bankTransfers: BankTransfers, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: BankTransfers;  }> {
        const localVarPath = this.basePath + '/BankTransfers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createBankTransfer.');
        }

        // verify required parameter 'bankTransfers' is not null or undefined
        if (bankTransfers === null || bankTransfers === undefined) {
            throw new Error('Required parameter bankTransfers was null or undefined when calling createBankTransfer.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(bankTransfers, "BankTransfers"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: BankTransfers;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "BankTransfers");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @param xeroTenantId Xero identifier for Tenant
     * @param bankTransferID Xero generated unique identifier for a bank transfer
     * @param fileName Name of the attachment
     * @param body Byte array of file in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createBankTransferAttachmentByFileName (xeroTenantId: string, bankTransferID: string, fileName: string, body: fs.ReadStream | Readable | Buffer , idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/BankTransfers/{BankTransferID}/Attachments/{FileName}'
            .replace('{' + 'BankTransferID' + '}', encodeURIComponent(String(bankTransferID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createBankTransferAttachmentByFileName.');
        }

        // verify required parameter 'bankTransferID' is not null or undefined
        if (bankTransferID === null || bankTransferID === undefined) {
            throw new Error('Required parameter bankTransferID was null or undefined when calling createBankTransferAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling createBankTransferAttachmentByFileName.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createBankTransferAttachmentByFileName.');
        }
        this.binaryHeaders = {'Accept': 'application/json'};
        (<any>Object).assign(localVarHeaderParams, this.binaryHeaders);
        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(body, "string"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
        }).then(() => {
            // Reads file stream as chunks so we can put it in body of request.
            // This collects the whole file into memory, which is why we do it _after_ authentication.
            return new Promise<any[]>((resolve, reject) => {
               	let bodyStream;
                bodyStream = Buffer.isBuffer(body) ? Readable.from(body) : body
                const fileContents: any[] = [];
                bodyStream.on('data', (chunk) => {
                    fileContents.push(chunk);
                });
                bodyStream.on('end', () => {
                    resolve(fileContents);
                });
                bodyStream.on('error', (err) => {
                    reject(err);
                })
            });
        }).then((fileContents) => {
            const file = Buffer.concat(fileContents);
            localVarRequestOptions.data = file;
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a history record for a specific bank transfer
     * @param xeroTenantId Xero identifier for Tenant
     * @param bankTransferID Xero generated unique identifier for a bank transfer
     * @param historyRecords HistoryRecords containing an array of HistoryRecord objects in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createBankTransferHistoryRecord (xeroTenantId: string, bankTransferID: string, historyRecords: HistoryRecords, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/BankTransfers/{BankTransferID}/History'
            .replace('{' + 'BankTransferID' + '}', encodeURIComponent(String(bankTransferID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createBankTransferHistoryRecord.');
        }

        // verify required parameter 'bankTransferID' is not null or undefined
        if (bankTransferID === null || bankTransferID === undefined) {
            throw new Error('Required parameter bankTransferID was null or undefined when calling createBankTransferHistoryRecord.');
        }

        // verify required parameter 'historyRecords' is not null or undefined
        if (historyRecords === null || historyRecords === undefined) {
            throw new Error('Required parameter historyRecords was null or undefined when calling createBankTransferHistoryRecord.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(historyRecords, "HistoryRecords"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates one or many batch payments for invoices
     * @param xeroTenantId Xero identifier for Tenant
     * @param batchPayments BatchPayments with an array of Payments in body of request
     * @param summarizeErrors If false return 200 OK and mix of successfully created objects and any with validation errors
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createBatchPayment (xeroTenantId: string, batchPayments: BatchPayments, summarizeErrors?: boolean, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: BatchPayments;  }> {
        const localVarPath = this.basePath + '/BatchPayments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createBatchPayment.');
        }

        // verify required parameter 'batchPayments' is not null or undefined
        if (batchPayments === null || batchPayments === undefined) {
            throw new Error('Required parameter batchPayments was null or undefined when calling createBatchPayment.');
        }

        if (summarizeErrors !== undefined) {
            localVarQueryParameters['summarizeErrors'] = ObjectSerializer.serialize(summarizeErrors, "boolean");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(batchPayments, "BatchPayments"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: BatchPayments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "BatchPayments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a history record for a specific batch payment
     * @param xeroTenantId Xero identifier for Tenant
     * @param batchPaymentID Unique identifier for BatchPayment
     * @param historyRecords HistoryRecords containing an array of HistoryRecord objects in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createBatchPaymentHistoryRecord (xeroTenantId: string, batchPaymentID: string, historyRecords: HistoryRecords, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/BatchPayments/{BatchPaymentID}/History'
            .replace('{' + 'BatchPaymentID' + '}', encodeURIComponent(String(batchPaymentID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createBatchPaymentHistoryRecord.');
        }

        // verify required parameter 'batchPaymentID' is not null or undefined
        if (batchPaymentID === null || batchPaymentID === undefined) {
            throw new Error('Required parameter batchPaymentID was null or undefined when calling createBatchPaymentHistoryRecord.');
        }

        // verify required parameter 'historyRecords' is not null or undefined
        if (historyRecords === null || historyRecords === undefined) {
            throw new Error('Required parameter historyRecords was null or undefined when calling createBatchPaymentHistoryRecord.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(historyRecords, "HistoryRecords"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new custom payment service for a specific branding theme
     * @param xeroTenantId Xero identifier for Tenant
     * @param brandingThemeID Unique identifier for a Branding Theme
     * @param paymentServices PaymentServices array with PaymentService object in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createBrandingThemePaymentServices (xeroTenantId: string, brandingThemeID: string, paymentServices: PaymentServices, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: PaymentServices;  }> {
        const localVarPath = this.basePath + '/BrandingThemes/{BrandingThemeID}/PaymentServices'
            .replace('{' + 'BrandingThemeID' + '}', encodeURIComponent(String(brandingThemeID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createBrandingThemePaymentServices.');
        }

        // verify required parameter 'brandingThemeID' is not null or undefined
        if (brandingThemeID === null || brandingThemeID === undefined) {
            throw new Error('Required parameter brandingThemeID was null or undefined when calling createBrandingThemePaymentServices.');
        }

        // verify required parameter 'paymentServices' is not null or undefined
        if (paymentServices === null || paymentServices === undefined) {
            throw new Error('Required parameter paymentServices was null or undefined when calling createBrandingThemePaymentServices.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(paymentServices, "PaymentServices"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: PaymentServices;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "PaymentServices");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @param xeroTenantId Xero identifier for Tenant
     * @param contactID Unique identifier for a Contact
     * @param fileName Name of the attachment
     * @param body Byte array of file in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createContactAttachmentByFileName (xeroTenantId: string, contactID: string, fileName: string, body: fs.ReadStream | Readable | Buffer , idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/Contacts/{ContactID}/Attachments/{FileName}'
            .replace('{' + 'ContactID' + '}', encodeURIComponent(String(contactID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createContactAttachmentByFileName.');
        }

        // verify required parameter 'contactID' is not null or undefined
        if (contactID === null || contactID === undefined) {
            throw new Error('Required parameter contactID was null or undefined when calling createContactAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling createContactAttachmentByFileName.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createContactAttachmentByFileName.');
        }
        this.binaryHeaders = {'Accept': 'application/json'};
        (<any>Object).assign(localVarHeaderParams, this.binaryHeaders);
        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(body, "string"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
        }).then(() => {
            // Reads file stream as chunks so we can put it in body of request.
            // This collects the whole file into memory, which is why we do it _after_ authentication.
            return new Promise<any[]>((resolve, reject) => {
               	let bodyStream;
                bodyStream = Buffer.isBuffer(body) ? Readable.from(body) : body
                const fileContents: any[] = [];
                bodyStream.on('data', (chunk) => {
                    fileContents.push(chunk);
                });
                bodyStream.on('end', () => {
                    resolve(fileContents);
                });
                bodyStream.on('error', (err) => {
                    reject(err);
                })
            });
        }).then((fileContents) => {
            const file = Buffer.concat(fileContents);
            localVarRequestOptions.data = file;
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a contact group
     * @param xeroTenantId Xero identifier for Tenant
     * @param contactGroups ContactGroups with an array of names in request body
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createContactGroup (xeroTenantId: string, contactGroups: ContactGroups, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: ContactGroups;  }> {
        const localVarPath = this.basePath + '/ContactGroups';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createContactGroup.');
        }

        // verify required parameter 'contactGroups' is not null or undefined
        if (contactGroups === null || contactGroups === undefined) {
            throw new Error('Required parameter contactGroups was null or undefined when calling createContactGroup.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(contactGroups, "ContactGroups"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: ContactGroups;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "ContactGroups");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates contacts to a specific contact group
     * @param xeroTenantId Xero identifier for Tenant
     * @param contactGroupID Unique identifier for a Contact Group
     * @param contacts Contacts with array of contacts specifying the ContactID to be added to ContactGroup in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createContactGroupContacts (xeroTenantId: string, contactGroupID: string, contacts: Contacts, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Contacts;  }> {
        const localVarPath = this.basePath + '/ContactGroups/{ContactGroupID}/Contacts'
            .replace('{' + 'ContactGroupID' + '}', encodeURIComponent(String(contactGroupID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createContactGroupContacts.');
        }

        // verify required parameter 'contactGroupID' is not null or undefined
        if (contactGroupID === null || contactGroupID === undefined) {
            throw new Error('Required parameter contactGroupID was null or undefined when calling createContactGroupContacts.');
        }

        // verify required parameter 'contacts' is not null or undefined
        if (contacts === null || contacts === undefined) {
            throw new Error('Required parameter contacts was null or undefined when calling createContactGroupContacts.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(contacts, "Contacts"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Contacts;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Contacts");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new history record for a specific contact
     * @param xeroTenantId Xero identifier for Tenant
     * @param contactID Unique identifier for a Contact
     * @param historyRecords HistoryRecords containing an array of HistoryRecord objects in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createContactHistory (xeroTenantId: string, contactID: string, historyRecords: HistoryRecords, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/Contacts/{ContactID}/History'
            .replace('{' + 'ContactID' + '}', encodeURIComponent(String(contactID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createContactHistory.');
        }

        // verify required parameter 'contactID' is not null or undefined
        if (contactID === null || contactID === undefined) {
            throw new Error('Required parameter contactID was null or undefined when calling createContactHistory.');
        }

        // verify required parameter 'historyRecords' is not null or undefined
        if (historyRecords === null || historyRecords === undefined) {
            throw new Error('Required parameter historyRecords was null or undefined when calling createContactHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(historyRecords, "HistoryRecords"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates multiple contacts (bulk) in a Xero organisation
     * @param xeroTenantId Xero identifier for Tenant
     * @param contacts Contacts with an array of Contact objects to create in body of request
     * @param summarizeErrors If false return 200 OK and mix of successfully created objects and any with validation errors
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createContacts (xeroTenantId: string, contacts: Contacts, summarizeErrors?: boolean, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Contacts;  }> {
        const localVarPath = this.basePath + '/Contacts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createContacts.');
        }

        // verify required parameter 'contacts' is not null or undefined
        if (contacts === null || contacts === undefined) {
            throw new Error('Required parameter contacts was null or undefined when calling createContacts.');
        }

        if (summarizeErrors !== undefined) {
            localVarQueryParameters['summarizeErrors'] = ObjectSerializer.serialize(summarizeErrors, "boolean");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(contacts, "Contacts"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Contacts;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Contacts");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates allocation for a specific credit note
     * @param xeroTenantId Xero identifier for Tenant
     * @param creditNoteID Unique identifier for a Credit Note
     * @param allocations Allocations with array of Allocation object in body of request.
     * @param summarizeErrors If false return 200 OK and mix of successfully created objects and any with validation errors
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createCreditNoteAllocation (xeroTenantId: string, creditNoteID: string, allocations: Allocations, summarizeErrors?: boolean, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Allocations;  }> {
        const localVarPath = this.basePath + '/CreditNotes/{CreditNoteID}/Allocations'
            .replace('{' + 'CreditNoteID' + '}', encodeURIComponent(String(creditNoteID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createCreditNoteAllocation.');
        }

        // verify required parameter 'creditNoteID' is not null or undefined
        if (creditNoteID === null || creditNoteID === undefined) {
            throw new Error('Required parameter creditNoteID was null or undefined when calling createCreditNoteAllocation.');
        }

        // verify required parameter 'allocations' is not null or undefined
        if (allocations === null || allocations === undefined) {
            throw new Error('Required parameter allocations was null or undefined when calling createCreditNoteAllocation.');
        }

        if (summarizeErrors !== undefined) {
            localVarQueryParameters['summarizeErrors'] = ObjectSerializer.serialize(summarizeErrors, "boolean");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(allocations, "Allocations"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Allocations;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Allocations");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates an attachment for a specific credit note
     * @param xeroTenantId Xero identifier for Tenant
     * @param creditNoteID Unique identifier for a Credit Note
     * @param fileName Name of the attachment
     * @param body Byte array of file in body of request
     * @param includeOnline Allows an attachment to be seen by the end customer within their online invoice
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createCreditNoteAttachmentByFileName (xeroTenantId: string, creditNoteID: string, fileName: string, body: fs.ReadStream | Readable | Buffer , includeOnline?: boolean, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/CreditNotes/{CreditNoteID}/Attachments/{FileName}'
            .replace('{' + 'CreditNoteID' + '}', encodeURIComponent(String(creditNoteID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createCreditNoteAttachmentByFileName.');
        }

        // verify required parameter 'creditNoteID' is not null or undefined
        if (creditNoteID === null || creditNoteID === undefined) {
            throw new Error('Required parameter creditNoteID was null or undefined when calling createCreditNoteAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling createCreditNoteAttachmentByFileName.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createCreditNoteAttachmentByFileName.');
        }
        this.binaryHeaders = {'Accept': 'application/json'};
        (<any>Object).assign(localVarHeaderParams, this.binaryHeaders);
        if (includeOnline !== undefined) {
            localVarQueryParameters['IncludeOnline'] = ObjectSerializer.serialize(includeOnline, "boolean");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(body, "string"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
        }).then(() => {
            // Reads file stream as chunks so we can put it in body of request.
            // This collects the whole file into memory, which is why we do it _after_ authentication.
            return new Promise<any[]>((resolve, reject) => {
               	let bodyStream;
                bodyStream = Buffer.isBuffer(body) ? Readable.from(body) : body
                const fileContents: any[] = [];
                bodyStream.on('data', (chunk) => {
                    fileContents.push(chunk);
                });
                bodyStream.on('end', () => {
                    resolve(fileContents);
                });
                bodyStream.on('error', (err) => {
                    reject(err);
                })
            });
        }).then((fileContents) => {
            const file = Buffer.concat(fileContents);
            localVarRequestOptions.data = file;
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves history records of a specific credit note
     * @param xeroTenantId Xero identifier for Tenant
     * @param creditNoteID Unique identifier for a Credit Note
     * @param historyRecords HistoryRecords containing an array of HistoryRecord objects in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createCreditNoteHistory (xeroTenantId: string, creditNoteID: string, historyRecords: HistoryRecords, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/CreditNotes/{CreditNoteID}/History'
            .replace('{' + 'CreditNoteID' + '}', encodeURIComponent(String(creditNoteID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createCreditNoteHistory.');
        }

        // verify required parameter 'creditNoteID' is not null or undefined
        if (creditNoteID === null || creditNoteID === undefined) {
            throw new Error('Required parameter creditNoteID was null or undefined when calling createCreditNoteHistory.');
        }

        // verify required parameter 'historyRecords' is not null or undefined
        if (historyRecords === null || historyRecords === undefined) {
            throw new Error('Required parameter historyRecords was null or undefined when calling createCreditNoteHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(historyRecords, "HistoryRecords"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a new credit note
     * @param xeroTenantId Xero identifier for Tenant
     * @param creditNotes Credit Notes with array of CreditNote object in body of request
     * @param summarizeErrors If false return 200 OK and mix of successfully created objects and any with validation errors
     * @param unitdp e.g. unitdp&#x3D;4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createCreditNotes (xeroTenantId: string, creditNotes: CreditNotes, summarizeErrors?: boolean, unitdp?: number, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: CreditNotes;  }> {
        const localVarPath = this.basePath + '/CreditNotes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createCreditNotes.');
        }

        // verify required parameter 'creditNotes' is not null or undefined
        if (creditNotes === null || creditNotes === undefined) {
            throw new Error('Required parameter creditNotes was null or undefined when calling createCreditNotes.');
        }

        if (summarizeErrors !== undefined) {
            localVarQueryParameters['summarizeErrors'] = ObjectSerializer.serialize(summarizeErrors, "boolean");
        }

        if (unitdp !== undefined) {
            localVarQueryParameters['unitdp'] = ObjectSerializer.serialize(unitdp, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(creditNotes, "CreditNotes"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: CreditNotes;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "CreditNotes");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Create a new currency for a Xero organisation
     * @param xeroTenantId Xero identifier for Tenant
     * @param currency Currency object in the body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createCurrency (xeroTenantId: string, currency: Currency, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Currencies;  }> {
        const localVarPath = this.basePath + '/Currencies';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createCurrency.');
        }

        // verify required parameter 'currency' is not null or undefined
        if (currency === null || currency === undefined) {
            throw new Error('Required parameter currency was null or undefined when calling createCurrency.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(currency, "Currency"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Currencies;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Currencies");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates new employees used in Xero payrun
     * @param xeroTenantId Xero identifier for Tenant
     * @param employees Employees with array of Employee object in body of request
     * @param summarizeErrors If false return 200 OK and mix of successfully created objects and any with validation errors
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createEmployees (xeroTenantId: string, employees: Employees, summarizeErrors?: boolean, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Employees;  }> {
        const localVarPath = this.basePath + '/Employees';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createEmployees.');
        }

        // verify required parameter 'employees' is not null or undefined
        if (employees === null || employees === undefined) {
            throw new Error('Required parameter employees was null or undefined when calling createEmployees.');
        }

        if (summarizeErrors !== undefined) {
            localVarQueryParameters['summarizeErrors'] = ObjectSerializer.serialize(summarizeErrors, "boolean");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(employees, "Employees"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Employees;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Employees");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a history record for a specific expense claim
     * @param xeroTenantId Xero identifier for Tenant
     * @param expenseClaimID Unique identifier for a ExpenseClaim
     * @param historyRecords HistoryRecords containing an array of HistoryRecord objects in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createExpenseClaimHistory (xeroTenantId: string, expenseClaimID: string, historyRecords: HistoryRecords, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/ExpenseClaims/{ExpenseClaimID}/History'
            .replace('{' + 'ExpenseClaimID' + '}', encodeURIComponent(String(expenseClaimID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createExpenseClaimHistory.');
        }

        // verify required parameter 'expenseClaimID' is not null or undefined
        if (expenseClaimID === null || expenseClaimID === undefined) {
            throw new Error('Required parameter expenseClaimID was null or undefined when calling createExpenseClaimHistory.');
        }

        // verify required parameter 'historyRecords' is not null or undefined
        if (historyRecords === null || historyRecords === undefined) {
            throw new Error('Required parameter historyRecords was null or undefined when calling createExpenseClaimHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(historyRecords, "HistoryRecords"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates expense claims
     * @param xeroTenantId Xero identifier for Tenant
     * @param expenseClaims ExpenseClaims with array of ExpenseClaim object in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createExpenseClaims (xeroTenantId: string, expenseClaims: ExpenseClaims, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: ExpenseClaims;  }> {
        const localVarPath = this.basePath + '/ExpenseClaims';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createExpenseClaims.');
        }

        // verify required parameter 'expenseClaims' is not null or undefined
        if (expenseClaims === null || expenseClaims === undefined) {
            throw new Error('Required parameter expenseClaims was null or undefined when calling createExpenseClaims.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(expenseClaims, "ExpenseClaims"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: ExpenseClaims;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "ExpenseClaims");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates an attachment for a specific invoice or purchase bill by filename
     * @param xeroTenantId Xero identifier for Tenant
     * @param invoiceID Unique identifier for an Invoice
     * @param fileName Name of the attachment
     * @param body Byte array of file in body of request
     * @param includeOnline Allows an attachment to be seen by the end customer within their online invoice
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createInvoiceAttachmentByFileName (xeroTenantId: string, invoiceID: string, fileName: string, body: fs.ReadStream | Readable | Buffer , includeOnline?: boolean, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/Invoices/{InvoiceID}/Attachments/{FileName}'
            .replace('{' + 'InvoiceID' + '}', encodeURIComponent(String(invoiceID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createInvoiceAttachmentByFileName.');
        }

        // verify required parameter 'invoiceID' is not null or undefined
        if (invoiceID === null || invoiceID === undefined) {
            throw new Error('Required parameter invoiceID was null or undefined when calling createInvoiceAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling createInvoiceAttachmentByFileName.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createInvoiceAttachmentByFileName.');
        }
        this.binaryHeaders = {'Accept': 'application/json'};
        (<any>Object).assign(localVarHeaderParams, this.binaryHeaders);
        if (includeOnline !== undefined) {
            localVarQueryParameters['IncludeOnline'] = ObjectSerializer.serialize(includeOnline, "boolean");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(body, "string"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
        }).then(() => {
            // Reads file stream as chunks so we can put it in body of request.
            // This collects the whole file into memory, which is why we do it _after_ authentication.
            return new Promise<any[]>((resolve, reject) => {
               	let bodyStream;
                bodyStream = Buffer.isBuffer(body) ? Readable.from(body) : body
                const fileContents: any[] = [];
                bodyStream.on('data', (chunk) => {
                    fileContents.push(chunk);
                });
                bodyStream.on('end', () => {
                    resolve(fileContents);
                });
                bodyStream.on('error', (err) => {
                    reject(err);
                })
            });
        }).then((fileContents) => {
            const file = Buffer.concat(fileContents);
            localVarRequestOptions.data = file;
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a history record for a specific invoice
     * @param xeroTenantId Xero identifier for Tenant
     * @param invoiceID Unique identifier for an Invoice
     * @param historyRecords HistoryRecords containing an array of HistoryRecord objects in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createInvoiceHistory (xeroTenantId: string, invoiceID: string, historyRecords: HistoryRecords, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/Invoices/{InvoiceID}/History'
            .replace('{' + 'InvoiceID' + '}', encodeURIComponent(String(invoiceID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createInvoiceHistory.');
        }

        // verify required parameter 'invoiceID' is not null or undefined
        if (invoiceID === null || invoiceID === undefined) {
            throw new Error('Required parameter invoiceID was null or undefined when calling createInvoiceHistory.');
        }

        // verify required parameter 'historyRecords' is not null or undefined
        if (historyRecords === null || historyRecords === undefined) {
            throw new Error('Required parameter historyRecords was null or undefined when calling createInvoiceHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(historyRecords, "HistoryRecords"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates one or more sales invoices or purchase bills
     * @param xeroTenantId Xero identifier for Tenant
     * @param invoices Invoices with an array of invoice objects in body of request
     * @param summarizeErrors If false return 200 OK and mix of successfully created objects and any with validation errors
     * @param unitdp e.g. unitdp&#x3D;4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createInvoices (xeroTenantId: string, invoices: Invoices, summarizeErrors?: boolean, unitdp?: number, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Invoices;  }> {
        const localVarPath = this.basePath + '/Invoices';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createInvoices.');
        }

        // verify required parameter 'invoices' is not null or undefined
        if (invoices === null || invoices === undefined) {
            throw new Error('Required parameter invoices was null or undefined when calling createInvoices.');
        }

        if (summarizeErrors !== undefined) {
            localVarQueryParameters['summarizeErrors'] = ObjectSerializer.serialize(summarizeErrors, "boolean");
        }

        if (unitdp !== undefined) {
            localVarQueryParameters['unitdp'] = ObjectSerializer.serialize(unitdp, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(invoices, "Invoices"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Invoices;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Invoices");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a history record for a specific item
     * @param xeroTenantId Xero identifier for Tenant
     * @param itemID Unique identifier for an Item
     * @param historyRecords HistoryRecords containing an array of HistoryRecord objects in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createItemHistory (xeroTenantId: string, itemID: string, historyRecords: HistoryRecords, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/Items/{ItemID}/History'
            .replace('{' + 'ItemID' + '}', encodeURIComponent(String(itemID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createItemHistory.');
        }

        // verify required parameter 'itemID' is not null or undefined
        if (itemID === null || itemID === undefined) {
            throw new Error('Required parameter itemID was null or undefined when calling createItemHistory.');
        }

        // verify required parameter 'historyRecords' is not null or undefined
        if (historyRecords === null || historyRecords === undefined) {
            throw new Error('Required parameter historyRecords was null or undefined when calling createItemHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(historyRecords, "HistoryRecords"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates one or more items
     * @param xeroTenantId Xero identifier for Tenant
     * @param items Items with an array of Item objects in body of request
     * @param summarizeErrors If false return 200 OK and mix of successfully created objects and any with validation errors
     * @param unitdp e.g. unitdp&#x3D;4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createItems (xeroTenantId: string, items: Items, summarizeErrors?: boolean, unitdp?: number, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Items;  }> {
        const localVarPath = this.basePath + '/Items';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createItems.');
        }

        // verify required parameter 'items' is not null or undefined
        if (items === null || items === undefined) {
            throw new Error('Required parameter items was null or undefined when calling createItems.');
        }

        if (summarizeErrors !== undefined) {
            localVarQueryParameters['summarizeErrors'] = ObjectSerializer.serialize(summarizeErrors, "boolean");
        }

        if (unitdp !== undefined) {
            localVarQueryParameters['unitdp'] = ObjectSerializer.serialize(unitdp, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(items, "Items"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Items;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Items");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates linked transactions (billable expenses)
     * @param xeroTenantId Xero identifier for Tenant
     * @param linkedTransaction LinkedTransaction object in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createLinkedTransaction (xeroTenantId: string, linkedTransaction: LinkedTransaction, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: LinkedTransactions;  }> {
        const localVarPath = this.basePath + '/LinkedTransactions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createLinkedTransaction.');
        }

        // verify required parameter 'linkedTransaction' is not null or undefined
        if (linkedTransaction === null || linkedTransaction === undefined) {
            throw new Error('Required parameter linkedTransaction was null or undefined when calling createLinkedTransaction.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(linkedTransaction, "LinkedTransaction"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: LinkedTransactions;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "LinkedTransactions");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a specific attachment for a specific manual journal by file name
     * @param xeroTenantId Xero identifier for Tenant
     * @param manualJournalID Unique identifier for a ManualJournal
     * @param fileName Name of the attachment
     * @param body Byte array of file in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createManualJournalAttachmentByFileName (xeroTenantId: string, manualJournalID: string, fileName: string, body: fs.ReadStream | Readable | Buffer , idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/ManualJournals/{ManualJournalID}/Attachments/{FileName}'
            .replace('{' + 'ManualJournalID' + '}', encodeURIComponent(String(manualJournalID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createManualJournalAttachmentByFileName.');
        }

        // verify required parameter 'manualJournalID' is not null or undefined
        if (manualJournalID === null || manualJournalID === undefined) {
            throw new Error('Required parameter manualJournalID was null or undefined when calling createManualJournalAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling createManualJournalAttachmentByFileName.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createManualJournalAttachmentByFileName.');
        }
        this.binaryHeaders = {'Accept': 'application/json'};
        (<any>Object).assign(localVarHeaderParams, this.binaryHeaders);
        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(body, "string"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
        }).then(() => {
            // Reads file stream as chunks so we can put it in body of request.
            // This collects the whole file into memory, which is why we do it _after_ authentication.
            return new Promise<any[]>((resolve, reject) => {
               	let bodyStream;
                bodyStream = Buffer.isBuffer(body) ? Readable.from(body) : body
                const fileContents: any[] = [];
                bodyStream.on('data', (chunk) => {
                    fileContents.push(chunk);
                });
                bodyStream.on('end', () => {
                    resolve(fileContents);
                });
                bodyStream.on('error', (err) => {
                    reject(err);
                })
            });
        }).then((fileContents) => {
            const file = Buffer.concat(fileContents);
            localVarRequestOptions.data = file;
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a history record for a specific manual journal
     * @param xeroTenantId Xero identifier for Tenant
     * @param manualJournalID Unique identifier for a ManualJournal
     * @param historyRecords HistoryRecords containing an array of HistoryRecord objects in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createManualJournalHistoryRecord (xeroTenantId: string, manualJournalID: string, historyRecords: HistoryRecords, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/ManualJournals/{ManualJournalID}/History'
            .replace('{' + 'ManualJournalID' + '}', encodeURIComponent(String(manualJournalID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createManualJournalHistoryRecord.');
        }

        // verify required parameter 'manualJournalID' is not null or undefined
        if (manualJournalID === null || manualJournalID === undefined) {
            throw new Error('Required parameter manualJournalID was null or undefined when calling createManualJournalHistoryRecord.');
        }

        // verify required parameter 'historyRecords' is not null or undefined
        if (historyRecords === null || historyRecords === undefined) {
            throw new Error('Required parameter historyRecords was null or undefined when calling createManualJournalHistoryRecord.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(historyRecords, "HistoryRecords"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates one or more manual journals
     * @param xeroTenantId Xero identifier for Tenant
     * @param manualJournals ManualJournals array with ManualJournal object in body of request
     * @param summarizeErrors If false return 200 OK and mix of successfully created objects and any with validation errors
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createManualJournals (xeroTenantId: string, manualJournals: ManualJournals, summarizeErrors?: boolean, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: ManualJournals;  }> {
        const localVarPath = this.basePath + '/ManualJournals';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createManualJournals.');
        }

        // verify required parameter 'manualJournals' is not null or undefined
        if (manualJournals === null || manualJournals === undefined) {
            throw new Error('Required parameter manualJournals was null or undefined when calling createManualJournals.');
        }

        if (summarizeErrors !== undefined) {
            localVarQueryParameters['summarizeErrors'] = ObjectSerializer.serialize(summarizeErrors, "boolean");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(manualJournals, "ManualJournals"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: ManualJournals;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "ManualJournals");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a single allocation for a specific overpayment
     * @param xeroTenantId Xero identifier for Tenant
     * @param overpaymentID Unique identifier for a Overpayment
     * @param allocations Allocations array with Allocation object in body of request
     * @param summarizeErrors If false return 200 OK and mix of successfully created objects and any with validation errors
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createOverpaymentAllocations (xeroTenantId: string, overpaymentID: string, allocations: Allocations, summarizeErrors?: boolean, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Allocations;  }> {
        const localVarPath = this.basePath + '/Overpayments/{OverpaymentID}/Allocations'
            .replace('{' + 'OverpaymentID' + '}', encodeURIComponent(String(overpaymentID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createOverpaymentAllocations.');
        }

        // verify required parameter 'overpaymentID' is not null or undefined
        if (overpaymentID === null || overpaymentID === undefined) {
            throw new Error('Required parameter overpaymentID was null or undefined when calling createOverpaymentAllocations.');
        }

        // verify required parameter 'allocations' is not null or undefined
        if (allocations === null || allocations === undefined) {
            throw new Error('Required parameter allocations was null or undefined when calling createOverpaymentAllocations.');
        }

        if (summarizeErrors !== undefined) {
            localVarQueryParameters['summarizeErrors'] = ObjectSerializer.serialize(summarizeErrors, "boolean");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(allocations, "Allocations"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Allocations;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Allocations");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a history record for a specific overpayment
     * @param xeroTenantId Xero identifier for Tenant
     * @param overpaymentID Unique identifier for a Overpayment
     * @param historyRecords HistoryRecords containing an array of HistoryRecord objects in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createOverpaymentHistory (xeroTenantId: string, overpaymentID: string, historyRecords: HistoryRecords, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/Overpayments/{OverpaymentID}/History'
            .replace('{' + 'OverpaymentID' + '}', encodeURIComponent(String(overpaymentID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createOverpaymentHistory.');
        }

        // verify required parameter 'overpaymentID' is not null or undefined
        if (overpaymentID === null || overpaymentID === undefined) {
            throw new Error('Required parameter overpaymentID was null or undefined when calling createOverpaymentHistory.');
        }

        // verify required parameter 'historyRecords' is not null or undefined
        if (historyRecords === null || historyRecords === undefined) {
            throw new Error('Required parameter historyRecords was null or undefined when calling createOverpaymentHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(historyRecords, "HistoryRecords"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a single payment for invoice or credit notes
     * @param xeroTenantId Xero identifier for Tenant
     * @param payment Request body with a single Payment object
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createPayment (xeroTenantId: string, payment: Payment, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Payments;  }> {
        const localVarPath = this.basePath + '/Payments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createPayment.');
        }

        // verify required parameter 'payment' is not null or undefined
        if (payment === null || payment === undefined) {
            throw new Error('Required parameter payment was null or undefined when calling createPayment.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(payment, "Payment"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Payments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Payments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a history record for a specific payment
     * @param xeroTenantId Xero identifier for Tenant
     * @param paymentID Unique identifier for a Payment
     * @param historyRecords HistoryRecords containing an array of HistoryRecord objects in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createPaymentHistory (xeroTenantId: string, paymentID: string, historyRecords: HistoryRecords, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/Payments/{PaymentID}/History'
            .replace('{' + 'PaymentID' + '}', encodeURIComponent(String(paymentID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createPaymentHistory.');
        }

        // verify required parameter 'paymentID' is not null or undefined
        if (paymentID === null || paymentID === undefined) {
            throw new Error('Required parameter paymentID was null or undefined when calling createPaymentHistory.');
        }

        // verify required parameter 'historyRecords' is not null or undefined
        if (historyRecords === null || historyRecords === undefined) {
            throw new Error('Required parameter historyRecords was null or undefined when calling createPaymentHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(historyRecords, "HistoryRecords"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a payment service
     * @param xeroTenantId Xero identifier for Tenant
     * @param paymentServices PaymentServices array with PaymentService object in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createPaymentService (xeroTenantId: string, paymentServices: PaymentServices, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: PaymentServices;  }> {
        const localVarPath = this.basePath + '/PaymentServices';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createPaymentService.');
        }

        // verify required parameter 'paymentServices' is not null or undefined
        if (paymentServices === null || paymentServices === undefined) {
            throw new Error('Required parameter paymentServices was null or undefined when calling createPaymentService.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(paymentServices, "PaymentServices"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: PaymentServices;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "PaymentServices");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates multiple payments for invoices or credit notes
     * @param xeroTenantId Xero identifier for Tenant
     * @param payments Payments array with Payment object in body of request
     * @param summarizeErrors If false return 200 OK and mix of successfully created objects and any with validation errors
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createPayments (xeroTenantId: string, payments: Payments, summarizeErrors?: boolean, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Payments;  }> {
        const localVarPath = this.basePath + '/Payments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createPayments.');
        }

        // verify required parameter 'payments' is not null or undefined
        if (payments === null || payments === undefined) {
            throw new Error('Required parameter payments was null or undefined when calling createPayments.');
        }

        if (summarizeErrors !== undefined) {
            localVarQueryParameters['summarizeErrors'] = ObjectSerializer.serialize(summarizeErrors, "boolean");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(payments, "Payments"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Payments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Payments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Allows you to create an Allocation for prepayments
     * @param xeroTenantId Xero identifier for Tenant
     * @param prepaymentID Unique identifier for a PrePayment
     * @param allocations Allocations with an array of Allocation object in body of request
     * @param summarizeErrors If false return 200 OK and mix of successfully created objects and any with validation errors
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createPrepaymentAllocations (xeroTenantId: string, prepaymentID: string, allocations: Allocations, summarizeErrors?: boolean, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Allocations;  }> {
        const localVarPath = this.basePath + '/Prepayments/{PrepaymentID}/Allocations'
            .replace('{' + 'PrepaymentID' + '}', encodeURIComponent(String(prepaymentID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createPrepaymentAllocations.');
        }

        // verify required parameter 'prepaymentID' is not null or undefined
        if (prepaymentID === null || prepaymentID === undefined) {
            throw new Error('Required parameter prepaymentID was null or undefined when calling createPrepaymentAllocations.');
        }

        // verify required parameter 'allocations' is not null or undefined
        if (allocations === null || allocations === undefined) {
            throw new Error('Required parameter allocations was null or undefined when calling createPrepaymentAllocations.');
        }

        if (summarizeErrors !== undefined) {
            localVarQueryParameters['summarizeErrors'] = ObjectSerializer.serialize(summarizeErrors, "boolean");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(allocations, "Allocations"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Allocations;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Allocations");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a history record for a specific prepayment
     * @param xeroTenantId Xero identifier for Tenant
     * @param prepaymentID Unique identifier for a PrePayment
     * @param historyRecords HistoryRecords containing an array of HistoryRecord objects in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createPrepaymentHistory (xeroTenantId: string, prepaymentID: string, historyRecords: HistoryRecords, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/Prepayments/{PrepaymentID}/History'
            .replace('{' + 'PrepaymentID' + '}', encodeURIComponent(String(prepaymentID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createPrepaymentHistory.');
        }

        // verify required parameter 'prepaymentID' is not null or undefined
        if (prepaymentID === null || prepaymentID === undefined) {
            throw new Error('Required parameter prepaymentID was null or undefined when calling createPrepaymentHistory.');
        }

        // verify required parameter 'historyRecords' is not null or undefined
        if (historyRecords === null || historyRecords === undefined) {
            throw new Error('Required parameter historyRecords was null or undefined when calling createPrepaymentHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(historyRecords, "HistoryRecords"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates attachment for a specific purchase order
     * @param xeroTenantId Xero identifier for Tenant
     * @param purchaseOrderID Unique identifier for an Purchase Order
     * @param fileName Name of the attachment
     * @param body Byte array of file in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createPurchaseOrderAttachmentByFileName (xeroTenantId: string, purchaseOrderID: string, fileName: string, body: fs.ReadStream | Readable | Buffer , idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/PurchaseOrders/{PurchaseOrderID}/Attachments/{FileName}'
            .replace('{' + 'PurchaseOrderID' + '}', encodeURIComponent(String(purchaseOrderID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createPurchaseOrderAttachmentByFileName.');
        }

        // verify required parameter 'purchaseOrderID' is not null or undefined
        if (purchaseOrderID === null || purchaseOrderID === undefined) {
            throw new Error('Required parameter purchaseOrderID was null or undefined when calling createPurchaseOrderAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling createPurchaseOrderAttachmentByFileName.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createPurchaseOrderAttachmentByFileName.');
        }
        this.binaryHeaders = {'Accept': 'application/json'};
        (<any>Object).assign(localVarHeaderParams, this.binaryHeaders);
        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(body, "string"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
        }).then(() => {
            // Reads file stream as chunks so we can put it in body of request.
            // This collects the whole file into memory, which is why we do it _after_ authentication.
            return new Promise<any[]>((resolve, reject) => {
               	let bodyStream;
                bodyStream = Buffer.isBuffer(body) ? Readable.from(body) : body
                const fileContents: any[] = [];
                bodyStream.on('data', (chunk) => {
                    fileContents.push(chunk);
                });
                bodyStream.on('end', () => {
                    resolve(fileContents);
                });
                bodyStream.on('error', (err) => {
                    reject(err);
                })
            });
        }).then((fileContents) => {
            const file = Buffer.concat(fileContents);
            localVarRequestOptions.data = file;
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a history record for a specific purchase orders
     * @param xeroTenantId Xero identifier for Tenant
     * @param purchaseOrderID Unique identifier for an Purchase Order
     * @param historyRecords HistoryRecords containing an array of HistoryRecord objects in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createPurchaseOrderHistory (xeroTenantId: string, purchaseOrderID: string, historyRecords: HistoryRecords, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/PurchaseOrders/{PurchaseOrderID}/History'
            .replace('{' + 'PurchaseOrderID' + '}', encodeURIComponent(String(purchaseOrderID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createPurchaseOrderHistory.');
        }

        // verify required parameter 'purchaseOrderID' is not null or undefined
        if (purchaseOrderID === null || purchaseOrderID === undefined) {
            throw new Error('Required parameter purchaseOrderID was null or undefined when calling createPurchaseOrderHistory.');
        }

        // verify required parameter 'historyRecords' is not null or undefined
        if (historyRecords === null || historyRecords === undefined) {
            throw new Error('Required parameter historyRecords was null or undefined when calling createPurchaseOrderHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(historyRecords, "HistoryRecords"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates one or more purchase orders
     * @param xeroTenantId Xero identifier for Tenant
     * @param purchaseOrders PurchaseOrders with an array of PurchaseOrder object in body of request
     * @param summarizeErrors If false return 200 OK and mix of successfully created objects and any with validation errors
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createPurchaseOrders (xeroTenantId: string, purchaseOrders: PurchaseOrders, summarizeErrors?: boolean, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: PurchaseOrders;  }> {
        const localVarPath = this.basePath + '/PurchaseOrders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createPurchaseOrders.');
        }

        // verify required parameter 'purchaseOrders' is not null or undefined
        if (purchaseOrders === null || purchaseOrders === undefined) {
            throw new Error('Required parameter purchaseOrders was null or undefined when calling createPurchaseOrders.');
        }

        if (summarizeErrors !== undefined) {
            localVarQueryParameters['summarizeErrors'] = ObjectSerializer.serialize(summarizeErrors, "boolean");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(purchaseOrders, "PurchaseOrders"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: PurchaseOrders;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "PurchaseOrders");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates attachment for a specific quote
     * @param xeroTenantId Xero identifier for Tenant
     * @param quoteID Unique identifier for an Quote
     * @param fileName Name of the attachment
     * @param body Byte array of file in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createQuoteAttachmentByFileName (xeroTenantId: string, quoteID: string, fileName: string, body: fs.ReadStream | Readable | Buffer , idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/Quotes/{QuoteID}/Attachments/{FileName}'
            .replace('{' + 'QuoteID' + '}', encodeURIComponent(String(quoteID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createQuoteAttachmentByFileName.');
        }

        // verify required parameter 'quoteID' is not null or undefined
        if (quoteID === null || quoteID === undefined) {
            throw new Error('Required parameter quoteID was null or undefined when calling createQuoteAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling createQuoteAttachmentByFileName.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createQuoteAttachmentByFileName.');
        }
        this.binaryHeaders = {'Accept': 'application/json'};
        (<any>Object).assign(localVarHeaderParams, this.binaryHeaders);
        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(body, "string"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
        }).then(() => {
            // Reads file stream as chunks so we can put it in body of request.
            // This collects the whole file into memory, which is why we do it _after_ authentication.
            return new Promise<any[]>((resolve, reject) => {
               	let bodyStream;
                bodyStream = Buffer.isBuffer(body) ? Readable.from(body) : body
                const fileContents: any[] = [];
                bodyStream.on('data', (chunk) => {
                    fileContents.push(chunk);
                });
                bodyStream.on('end', () => {
                    resolve(fileContents);
                });
                bodyStream.on('error', (err) => {
                    reject(err);
                })
            });
        }).then((fileContents) => {
            const file = Buffer.concat(fileContents);
            localVarRequestOptions.data = file;
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a history record for a specific quote
     * @param xeroTenantId Xero identifier for Tenant
     * @param quoteID Unique identifier for an Quote
     * @param historyRecords HistoryRecords containing an array of HistoryRecord objects in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createQuoteHistory (xeroTenantId: string, quoteID: string, historyRecords: HistoryRecords, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/Quotes/{QuoteID}/History'
            .replace('{' + 'QuoteID' + '}', encodeURIComponent(String(quoteID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createQuoteHistory.');
        }

        // verify required parameter 'quoteID' is not null or undefined
        if (quoteID === null || quoteID === undefined) {
            throw new Error('Required parameter quoteID was null or undefined when calling createQuoteHistory.');
        }

        // verify required parameter 'historyRecords' is not null or undefined
        if (historyRecords === null || historyRecords === undefined) {
            throw new Error('Required parameter historyRecords was null or undefined when calling createQuoteHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(historyRecords, "HistoryRecords"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Create one or more quotes
     * @param xeroTenantId Xero identifier for Tenant
     * @param quotes Quotes with an array of Quote object in body of request
     * @param summarizeErrors If false return 200 OK and mix of successfully created objects and any with validation errors
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createQuotes (xeroTenantId: string, quotes: Quotes, summarizeErrors?: boolean, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Quotes;  }> {
        const localVarPath = this.basePath + '/Quotes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createQuotes.');
        }

        // verify required parameter 'quotes' is not null or undefined
        if (quotes === null || quotes === undefined) {
            throw new Error('Required parameter quotes was null or undefined when calling createQuotes.');
        }

        if (summarizeErrors !== undefined) {
            localVarQueryParameters['summarizeErrors'] = ObjectSerializer.serialize(summarizeErrors, "boolean");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(quotes, "Quotes"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Quotes;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Quotes");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates draft expense claim receipts for any user
     * @param xeroTenantId Xero identifier for Tenant
     * @param receipts Receipts with an array of Receipt object in body of request
     * @param unitdp e.g. unitdp&#x3D;4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createReceipt (xeroTenantId: string, receipts: Receipts, unitdp?: number, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Receipts;  }> {
        const localVarPath = this.basePath + '/Receipts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createReceipt.');
        }

        // verify required parameter 'receipts' is not null or undefined
        if (receipts === null || receipts === undefined) {
            throw new Error('Required parameter receipts was null or undefined when calling createReceipt.');
        }

        if (unitdp !== undefined) {
            localVarQueryParameters['unitdp'] = ObjectSerializer.serialize(unitdp, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(receipts, "Receipts"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Receipts;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Receipts");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates an attachment on a specific expense claim receipts by file name
     * @param xeroTenantId Xero identifier for Tenant
     * @param receiptID Unique identifier for a Receipt
     * @param fileName Name of the attachment
     * @param body Byte array of file in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createReceiptAttachmentByFileName (xeroTenantId: string, receiptID: string, fileName: string, body: fs.ReadStream | Readable | Buffer , idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/Receipts/{ReceiptID}/Attachments/{FileName}'
            .replace('{' + 'ReceiptID' + '}', encodeURIComponent(String(receiptID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createReceiptAttachmentByFileName.');
        }

        // verify required parameter 'receiptID' is not null or undefined
        if (receiptID === null || receiptID === undefined) {
            throw new Error('Required parameter receiptID was null or undefined when calling createReceiptAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling createReceiptAttachmentByFileName.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createReceiptAttachmentByFileName.');
        }
        this.binaryHeaders = {'Accept': 'application/json'};
        (<any>Object).assign(localVarHeaderParams, this.binaryHeaders);
        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(body, "string"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
        }).then(() => {
            // Reads file stream as chunks so we can put it in body of request.
            // This collects the whole file into memory, which is why we do it _after_ authentication.
            return new Promise<any[]>((resolve, reject) => {
               	let bodyStream;
                bodyStream = Buffer.isBuffer(body) ? Readable.from(body) : body
                const fileContents: any[] = [];
                bodyStream.on('data', (chunk) => {
                    fileContents.push(chunk);
                });
                bodyStream.on('end', () => {
                    resolve(fileContents);
                });
                bodyStream.on('error', (err) => {
                    reject(err);
                })
            });
        }).then((fileContents) => {
            const file = Buffer.concat(fileContents);
            localVarRequestOptions.data = file;
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a history record for a specific receipt
     * @param xeroTenantId Xero identifier for Tenant
     * @param receiptID Unique identifier for a Receipt
     * @param historyRecords HistoryRecords containing an array of HistoryRecord objects in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createReceiptHistory (xeroTenantId: string, receiptID: string, historyRecords: HistoryRecords, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/Receipts/{ReceiptID}/History'
            .replace('{' + 'ReceiptID' + '}', encodeURIComponent(String(receiptID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createReceiptHistory.');
        }

        // verify required parameter 'receiptID' is not null or undefined
        if (receiptID === null || receiptID === undefined) {
            throw new Error('Required parameter receiptID was null or undefined when calling createReceiptHistory.');
        }

        // verify required parameter 'historyRecords' is not null or undefined
        if (historyRecords === null || historyRecords === undefined) {
            throw new Error('Required parameter historyRecords was null or undefined when calling createReceiptHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(historyRecords, "HistoryRecords"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates an attachment from a specific repeating invoices by file name
     * @param xeroTenantId Xero identifier for Tenant
     * @param repeatingInvoiceID Unique identifier for a Repeating Invoice
     * @param fileName Name of the attachment
     * @param body Byte array of file in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createRepeatingInvoiceAttachmentByFileName (xeroTenantId: string, repeatingInvoiceID: string, fileName: string, body: fs.ReadStream | Readable | Buffer , idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{FileName}'
            .replace('{' + 'RepeatingInvoiceID' + '}', encodeURIComponent(String(repeatingInvoiceID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createRepeatingInvoiceAttachmentByFileName.');
        }

        // verify required parameter 'repeatingInvoiceID' is not null or undefined
        if (repeatingInvoiceID === null || repeatingInvoiceID === undefined) {
            throw new Error('Required parameter repeatingInvoiceID was null or undefined when calling createRepeatingInvoiceAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling createRepeatingInvoiceAttachmentByFileName.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling createRepeatingInvoiceAttachmentByFileName.');
        }
        this.binaryHeaders = {'Accept': 'application/json'};
        (<any>Object).assign(localVarHeaderParams, this.binaryHeaders);
        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(body, "string"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
        }).then(() => {
            // Reads file stream as chunks so we can put it in body of request.
            // This collects the whole file into memory, which is why we do it _after_ authentication.
            return new Promise<any[]>((resolve, reject) => {
               	let bodyStream;
                bodyStream = Buffer.isBuffer(body) ? Readable.from(body) : body
                const fileContents: any[] = [];
                bodyStream.on('data', (chunk) => {
                    fileContents.push(chunk);
                });
                bodyStream.on('end', () => {
                    resolve(fileContents);
                });
                bodyStream.on('error', (err) => {
                    reject(err);
                })
            });
        }).then((fileContents) => {
            const file = Buffer.concat(fileContents);
            localVarRequestOptions.data = file;
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a  history record for a specific repeating invoice
     * @param xeroTenantId Xero identifier for Tenant
     * @param repeatingInvoiceID Unique identifier for a Repeating Invoice
     * @param historyRecords HistoryRecords containing an array of HistoryRecord objects in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createRepeatingInvoiceHistory (xeroTenantId: string, repeatingInvoiceID: string, historyRecords: HistoryRecords, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/RepeatingInvoices/{RepeatingInvoiceID}/History'
            .replace('{' + 'RepeatingInvoiceID' + '}', encodeURIComponent(String(repeatingInvoiceID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createRepeatingInvoiceHistory.');
        }

        // verify required parameter 'repeatingInvoiceID' is not null or undefined
        if (repeatingInvoiceID === null || repeatingInvoiceID === undefined) {
            throw new Error('Required parameter repeatingInvoiceID was null or undefined when calling createRepeatingInvoiceHistory.');
        }

        // verify required parameter 'historyRecords' is not null or undefined
        if (historyRecords === null || historyRecords === undefined) {
            throw new Error('Required parameter historyRecords was null or undefined when calling createRepeatingInvoiceHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(historyRecords, "HistoryRecords"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates one or more repeating invoice templates
     * @param xeroTenantId Xero identifier for Tenant
     * @param repeatingInvoices RepeatingInvoices with an array of repeating invoice objects in body of request
     * @param summarizeErrors If false return 200 OK and mix of successfully created objects and any with validation errors
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createRepeatingInvoices (xeroTenantId: string, repeatingInvoices: RepeatingInvoices, summarizeErrors?: boolean, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: RepeatingInvoices;  }> {
        const localVarPath = this.basePath + '/RepeatingInvoices';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createRepeatingInvoices.');
        }

        // verify required parameter 'repeatingInvoices' is not null or undefined
        if (repeatingInvoices === null || repeatingInvoices === undefined) {
            throw new Error('Required parameter repeatingInvoices was null or undefined when calling createRepeatingInvoices.');
        }

        if (summarizeErrors !== undefined) {
            localVarQueryParameters['summarizeErrors'] = ObjectSerializer.serialize(summarizeErrors, "boolean");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(repeatingInvoices, "RepeatingInvoices"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: RepeatingInvoices;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "RepeatingInvoices");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates one or more tax rates
     * @param xeroTenantId Xero identifier for Tenant
     * @param taxRates TaxRates array with TaxRate object in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createTaxRates (xeroTenantId: string, taxRates: TaxRates, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: TaxRates;  }> {
        const localVarPath = this.basePath + '/TaxRates';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createTaxRates.');
        }

        // verify required parameter 'taxRates' is not null or undefined
        if (taxRates === null || taxRates === undefined) {
            throw new Error('Required parameter taxRates was null or undefined when calling createTaxRates.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(taxRates, "TaxRates"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: TaxRates;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "TaxRates");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Create tracking categories
     * @param xeroTenantId Xero identifier for Tenant
     * @param trackingCategory TrackingCategory object in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createTrackingCategory (xeroTenantId: string, trackingCategory: TrackingCategory, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: TrackingCategories;  }> {
        const localVarPath = this.basePath + '/TrackingCategories';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createTrackingCategory.');
        }

        // verify required parameter 'trackingCategory' is not null or undefined
        if (trackingCategory === null || trackingCategory === undefined) {
            throw new Error('Required parameter trackingCategory was null or undefined when calling createTrackingCategory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(trackingCategory, "TrackingCategory"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: TrackingCategories;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "TrackingCategories");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates options for a specific tracking category
     * @param xeroTenantId Xero identifier for Tenant
     * @param trackingCategoryID Unique identifier for a TrackingCategory
     * @param trackingOption TrackingOption object in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async createTrackingOptions (xeroTenantId: string, trackingCategoryID: string, trackingOption: TrackingOption, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: TrackingOptions;  }> {
        const localVarPath = this.basePath + '/TrackingCategories/{TrackingCategoryID}/Options'
            .replace('{' + 'TrackingCategoryID' + '}', encodeURIComponent(String(trackingCategoryID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling createTrackingOptions.');
        }

        // verify required parameter 'trackingCategoryID' is not null or undefined
        if (trackingCategoryID === null || trackingCategoryID === undefined) {
            throw new Error('Required parameter trackingCategoryID was null or undefined when calling createTrackingOptions.');
        }

        // verify required parameter 'trackingOption' is not null or undefined
        if (trackingOption === null || trackingOption === undefined) {
            throw new Error('Required parameter trackingOption was null or undefined when calling createTrackingOptions.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'PUT',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(trackingOption, "TrackingOption"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: TrackingOptions;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "TrackingOptions");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a chart of accounts
     * @param xeroTenantId Xero identifier for Tenant
     * @param accountID Unique identifier for Account object
     */     
    public async deleteAccount (xeroTenantId: string, accountID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Accounts;  }> {
        const localVarPath = this.basePath + '/Accounts/{AccountID}'
            .replace('{' + 'AccountID' + '}', encodeURIComponent(String(accountID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling deleteAccount.');
        }

        // verify required parameter 'accountID' is not null or undefined
        if (accountID === null || accountID === undefined) {
            throw new Error('Required parameter accountID was null or undefined when calling deleteAccount.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Accounts;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Accounts");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific batch payment for invoices and credit notes
     * @param xeroTenantId Xero identifier for Tenant
     * @param batchPaymentDelete 
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async deleteBatchPayment (xeroTenantId: string, batchPaymentDelete: BatchPaymentDelete, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: BatchPayments;  }> {
        const localVarPath = this.basePath + '/BatchPayments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling deleteBatchPayment.');
        }

        // verify required parameter 'batchPaymentDelete' is not null or undefined
        if (batchPaymentDelete === null || batchPaymentDelete === undefined) {
            throw new Error('Required parameter batchPaymentDelete was null or undefined when calling deleteBatchPayment.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(batchPaymentDelete, "BatchPaymentDelete"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: BatchPayments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "BatchPayments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific batch payment for invoices and credit notes
     * @param xeroTenantId Xero identifier for Tenant
     * @param batchPaymentID Unique identifier for BatchPayment
     * @param batchPaymentDeleteByUrlParam 
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async deleteBatchPaymentByUrlParam (xeroTenantId: string, batchPaymentID: string, batchPaymentDeleteByUrlParam: BatchPaymentDeleteByUrlParam, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: BatchPayments;  }> {
        const localVarPath = this.basePath + '/BatchPayments/{BatchPaymentID}'
            .replace('{' + 'BatchPaymentID' + '}', encodeURIComponent(String(batchPaymentID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling deleteBatchPaymentByUrlParam.');
        }

        // verify required parameter 'batchPaymentID' is not null or undefined
        if (batchPaymentID === null || batchPaymentID === undefined) {
            throw new Error('Required parameter batchPaymentID was null or undefined when calling deleteBatchPaymentByUrlParam.');
        }

        // verify required parameter 'batchPaymentDeleteByUrlParam' is not null or undefined
        if (batchPaymentDeleteByUrlParam === null || batchPaymentDeleteByUrlParam === undefined) {
            throw new Error('Required parameter batchPaymentDeleteByUrlParam was null or undefined when calling deleteBatchPaymentByUrlParam.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(batchPaymentDeleteByUrlParam, "BatchPaymentDeleteByUrlParam"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: BatchPayments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "BatchPayments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a specific contact from a contact group using a unique contact Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param contactGroupID Unique identifier for a Contact Group
     * @param contactID Unique identifier for a Contact
     */     
    public async deleteContactGroupContact (xeroTenantId: string, contactGroupID: string, contactID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/ContactGroups/{ContactGroupID}/Contacts/{ContactID}'
            .replace('{' + 'ContactGroupID' + '}', encodeURIComponent(String(contactGroupID)))
            .replace('{' + 'ContactID' + '}', encodeURIComponent(String(contactID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling deleteContactGroupContact.');
        }

        // verify required parameter 'contactGroupID' is not null or undefined
        if (contactGroupID === null || contactGroupID === undefined) {
            throw new Error('Required parameter contactGroupID was null or undefined when calling deleteContactGroupContact.');
        }

        // verify required parameter 'contactID' is not null or undefined
        if (contactID === null || contactID === undefined) {
            throw new Error('Required parameter contactID was null or undefined when calling deleteContactGroupContact.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body?: any;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)

                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes all contacts from a specific contact group
     * @param xeroTenantId Xero identifier for Tenant
     * @param contactGroupID Unique identifier for a Contact Group
     */     
    public async deleteContactGroupContacts (xeroTenantId: string, contactGroupID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/ContactGroups/{ContactGroupID}/Contacts'
            .replace('{' + 'ContactGroupID' + '}', encodeURIComponent(String(contactGroupID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling deleteContactGroupContacts.');
        }

        // verify required parameter 'contactGroupID' is not null or undefined
        if (contactGroupID === null || contactGroupID === undefined) {
            throw new Error('Required parameter contactGroupID was null or undefined when calling deleteContactGroupContacts.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body?: any;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)

                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes an Allocation from a Credit Note
     * @param xeroTenantId Xero identifier for Tenant
     * @param creditNoteID Unique identifier for a Credit Note
     * @param allocationID Unique identifier for Allocation object
     */     
    public async deleteCreditNoteAllocations (xeroTenantId: string, creditNoteID: string, allocationID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Allocation;  }> {
        const localVarPath = this.basePath + '/CreditNotes/{CreditNoteID}/Allocations/{AllocationID}'
            .replace('{' + 'CreditNoteID' + '}', encodeURIComponent(String(creditNoteID)))
            .replace('{' + 'AllocationID' + '}', encodeURIComponent(String(allocationID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling deleteCreditNoteAllocations.');
        }

        // verify required parameter 'creditNoteID' is not null or undefined
        if (creditNoteID === null || creditNoteID === undefined) {
            throw new Error('Required parameter creditNoteID was null or undefined when calling deleteCreditNoteAllocations.');
        }

        // verify required parameter 'allocationID' is not null or undefined
        if (allocationID === null || allocationID === undefined) {
            throw new Error('Required parameter allocationID was null or undefined when calling deleteCreditNoteAllocations.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Allocation;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Allocation");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a specific item
     * @param xeroTenantId Xero identifier for Tenant
     * @param itemID Unique identifier for an Item
     */     
    public async deleteItem (xeroTenantId: string, itemID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/Items/{ItemID}'
            .replace('{' + 'ItemID' + '}', encodeURIComponent(String(itemID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling deleteItem.');
        }

        // verify required parameter 'itemID' is not null or undefined
        if (itemID === null || itemID === undefined) {
            throw new Error('Required parameter itemID was null or undefined when calling deleteItem.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body?: any;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)

                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a specific linked transactions (billable expenses)
     * @param xeroTenantId Xero identifier for Tenant
     * @param linkedTransactionID Unique identifier for a LinkedTransaction
     */     
    public async deleteLinkedTransaction (xeroTenantId: string, linkedTransactionID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/LinkedTransactions/{LinkedTransactionID}'
            .replace('{' + 'LinkedTransactionID' + '}', encodeURIComponent(String(linkedTransactionID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling deleteLinkedTransaction.');
        }

        // verify required parameter 'linkedTransactionID' is not null or undefined
        if (linkedTransactionID === null || linkedTransactionID === undefined) {
            throw new Error('Required parameter linkedTransactionID was null or undefined when calling deleteLinkedTransaction.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body?: any;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)

                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes an Allocation from an overpayment
     * @param xeroTenantId Xero identifier for Tenant
     * @param overpaymentID Unique identifier for a Overpayment
     * @param allocationID Unique identifier for Allocation object
     */     
    public async deleteOverpaymentAllocations (xeroTenantId: string, overpaymentID: string, allocationID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Allocation;  }> {
        const localVarPath = this.basePath + '/Overpayments/{OverpaymentID}/Allocations/{AllocationID}'
            .replace('{' + 'OverpaymentID' + '}', encodeURIComponent(String(overpaymentID)))
            .replace('{' + 'AllocationID' + '}', encodeURIComponent(String(allocationID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling deleteOverpaymentAllocations.');
        }

        // verify required parameter 'overpaymentID' is not null or undefined
        if (overpaymentID === null || overpaymentID === undefined) {
            throw new Error('Required parameter overpaymentID was null or undefined when calling deleteOverpaymentAllocations.');
        }

        // verify required parameter 'allocationID' is not null or undefined
        if (allocationID === null || allocationID === undefined) {
            throw new Error('Required parameter allocationID was null or undefined when calling deleteOverpaymentAllocations.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Allocation;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Allocation");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific payment for invoices and credit notes
     * @param xeroTenantId Xero identifier for Tenant
     * @param paymentID Unique identifier for a Payment
     * @param paymentDelete 
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async deletePayment (xeroTenantId: string, paymentID: string, paymentDelete: PaymentDelete, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Payments;  }> {
        const localVarPath = this.basePath + '/Payments/{PaymentID}'
            .replace('{' + 'PaymentID' + '}', encodeURIComponent(String(paymentID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling deletePayment.');
        }

        // verify required parameter 'paymentID' is not null or undefined
        if (paymentID === null || paymentID === undefined) {
            throw new Error('Required parameter paymentID was null or undefined when calling deletePayment.');
        }

        // verify required parameter 'paymentDelete' is not null or undefined
        if (paymentDelete === null || paymentDelete === undefined) {
            throw new Error('Required parameter paymentDelete was null or undefined when calling deletePayment.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(paymentDelete, "PaymentDelete"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Payments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Payments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes an Allocation from a Prepayment
     * @param xeroTenantId Xero identifier for Tenant
     * @param prepaymentID Unique identifier for a PrePayment
     * @param allocationID Unique identifier for Allocation object
     */     
    public async deletePrepaymentAllocations (xeroTenantId: string, prepaymentID: string, allocationID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Allocation;  }> {
        const localVarPath = this.basePath + '/Prepayments/{PrepaymentID}/Allocations/{AllocationID}'
            .replace('{' + 'PrepaymentID' + '}', encodeURIComponent(String(prepaymentID)))
            .replace('{' + 'AllocationID' + '}', encodeURIComponent(String(allocationID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling deletePrepaymentAllocations.');
        }

        // verify required parameter 'prepaymentID' is not null or undefined
        if (prepaymentID === null || prepaymentID === undefined) {
            throw new Error('Required parameter prepaymentID was null or undefined when calling deletePrepaymentAllocations.');
        }

        // verify required parameter 'allocationID' is not null or undefined
        if (allocationID === null || allocationID === undefined) {
            throw new Error('Required parameter allocationID was null or undefined when calling deletePrepaymentAllocations.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Allocation;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Allocation");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a specific tracking category
     * @param xeroTenantId Xero identifier for Tenant
     * @param trackingCategoryID Unique identifier for a TrackingCategory
     */     
    public async deleteTrackingCategory (xeroTenantId: string, trackingCategoryID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: TrackingCategories;  }> {
        const localVarPath = this.basePath + '/TrackingCategories/{TrackingCategoryID}'
            .replace('{' + 'TrackingCategoryID' + '}', encodeURIComponent(String(trackingCategoryID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling deleteTrackingCategory.');
        }

        // verify required parameter 'trackingCategoryID' is not null or undefined
        if (trackingCategoryID === null || trackingCategoryID === undefined) {
            throw new Error('Required parameter trackingCategoryID was null or undefined when calling deleteTrackingCategory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: TrackingCategories;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "TrackingCategories");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a specific option for a specific tracking category
     * @param xeroTenantId Xero identifier for Tenant
     * @param trackingCategoryID Unique identifier for a TrackingCategory
     * @param trackingOptionID Unique identifier for a Tracking Option
     */     
    public async deleteTrackingOptions (xeroTenantId: string, trackingCategoryID: string, trackingOptionID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: TrackingOptions;  }> {
        const localVarPath = this.basePath + '/TrackingCategories/{TrackingCategoryID}/Options/{TrackingOptionID}'
            .replace('{' + 'TrackingCategoryID' + '}', encodeURIComponent(String(trackingCategoryID)))
            .replace('{' + 'TrackingOptionID' + '}', encodeURIComponent(String(trackingOptionID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling deleteTrackingOptions.');
        }

        // verify required parameter 'trackingCategoryID' is not null or undefined
        if (trackingCategoryID === null || trackingCategoryID === undefined) {
            throw new Error('Required parameter trackingCategoryID was null or undefined when calling deleteTrackingOptions.');
        }

        // verify required parameter 'trackingOptionID' is not null or undefined
        if (trackingOptionID === null || trackingOptionID === undefined) {
            throw new Error('Required parameter trackingOptionID was null or undefined when calling deleteTrackingOptions.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'DELETE',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: TrackingOptions;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "TrackingOptions");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Sends a copy of a specific invoice to related contact via email
     * @param xeroTenantId Xero identifier for Tenant
     * @param invoiceID Unique identifier for an Invoice
     * @param requestEmpty 
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async emailInvoice (xeroTenantId: string, invoiceID: string, requestEmpty: RequestEmpty, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/Invoices/{InvoiceID}/Email'
            .replace('{' + 'InvoiceID' + '}', encodeURIComponent(String(invoiceID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling emailInvoice.');
        }

        // verify required parameter 'invoiceID' is not null or undefined
        if (invoiceID === null || invoiceID === undefined) {
            throw new Error('Required parameter invoiceID was null or undefined when calling emailInvoice.');
        }

        // verify required parameter 'requestEmpty' is not null or undefined
        if (requestEmpty === null || requestEmpty === undefined) {
            throw new Error('Required parameter requestEmpty was null or undefined when calling emailInvoice.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(requestEmpty, "RequestEmpty"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body?: any;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)

                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a single chart of accounts by using a unique account Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param accountID Unique identifier for Account object
     */     
    public async getAccount (xeroTenantId: string, accountID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Accounts;  }> {
        const localVarPath = this.basePath + '/Accounts/{AccountID}'
            .replace('{' + 'AccountID' + '}', encodeURIComponent(String(accountID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getAccount.');
        }

        // verify required parameter 'accountID' is not null or undefined
        if (accountID === null || accountID === undefined) {
            throw new Error('Required parameter accountID was null or undefined when calling getAccount.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Accounts;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Accounts");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves an attachment for a specific account by filename
     * @param xeroTenantId Xero identifier for Tenant
     * @param accountID Unique identifier for Account object
     * @param fileName Name of the attachment
     * @param contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
     */     
    public async getAccountAttachmentByFileName (xeroTenantId: string, accountID: string, fileName: string, contentType: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/Accounts/{AccountID}/Attachments/{FileName}'
            .replace('{' + 'AccountID' + '}', encodeURIComponent(String(accountID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/octet-stream"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getAccountAttachmentByFileName.');
        }

        // verify required parameter 'accountID' is not null or undefined
        if (accountID === null || accountID === undefined) {
            throw new Error('Required parameter accountID was null or undefined when calling getAccountAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling getAccountAttachmentByFileName.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling getAccountAttachmentByFileName.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['contentType'] = ObjectSerializer.serialize(contentType, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Buffer;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Buffer");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific attachment from a specific account using a unique attachment Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param accountID Unique identifier for Account object
     * @param attachmentID Unique identifier for Attachment object
     * @param contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
     */     
    public async getAccountAttachmentById (xeroTenantId: string, accountID: string, attachmentID: string, contentType: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/Accounts/{AccountID}/Attachments/{AttachmentID}'
            .replace('{' + 'AccountID' + '}', encodeURIComponent(String(accountID)))
            .replace('{' + 'AttachmentID' + '}', encodeURIComponent(String(attachmentID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/octet-stream"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getAccountAttachmentById.');
        }

        // verify required parameter 'accountID' is not null or undefined
        if (accountID === null || accountID === undefined) {
            throw new Error('Required parameter accountID was null or undefined when calling getAccountAttachmentById.');
        }

        // verify required parameter 'attachmentID' is not null or undefined
        if (attachmentID === null || attachmentID === undefined) {
            throw new Error('Required parameter attachmentID was null or undefined when calling getAccountAttachmentById.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling getAccountAttachmentById.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['contentType'] = ObjectSerializer.serialize(contentType, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Buffer;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Buffer");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves attachments for a specific accounts by using a unique account Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param accountID Unique identifier for Account object
     */     
    public async getAccountAttachments (xeroTenantId: string, accountID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/Accounts/{AccountID}/Attachments'
            .replace('{' + 'AccountID' + '}', encodeURIComponent(String(accountID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getAccountAttachments.');
        }

        // verify required parameter 'accountID' is not null or undefined
        if (accountID === null || accountID === undefined) {
            throw new Error('Required parameter accountID was null or undefined when calling getAccountAttachments.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the full chart of accounts
     * @param xeroTenantId Xero identifier for Tenant
     * @param ifModifiedSince Only records created or modified since this timestamp will be returned
     * @param where Filter by an any element
     * @param order Order by an any element
     */     
    public async getAccounts (xeroTenantId: string, ifModifiedSince?: Date, where?: string, order?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Accounts;  }> {
        const localVarPath = this.basePath + '/Accounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getAccounts.');
        }

        if (where !== undefined) {
            localVarQueryParameters['where'] = ObjectSerializer.serialize(where, "string");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['If-Modified-Since'] = ObjectSerializer.serialize(ifModifiedSince, "Date");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Accounts;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Accounts");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a single spent or received money transaction by using a unique bank transaction Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param bankTransactionID Xero generated unique identifier for a bank transaction
     * @param unitdp e.g. unitdp&#x3D;4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
     */     
    public async getBankTransaction (xeroTenantId: string, bankTransactionID: string, unitdp?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: BankTransactions;  }> {
        const localVarPath = this.basePath + '/BankTransactions/{BankTransactionID}'
            .replace('{' + 'BankTransactionID' + '}', encodeURIComponent(String(bankTransactionID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getBankTransaction.');
        }

        // verify required parameter 'bankTransactionID' is not null or undefined
        if (bankTransactionID === null || bankTransactionID === undefined) {
            throw new Error('Required parameter bankTransactionID was null or undefined when calling getBankTransaction.');
        }

        if (unitdp !== undefined) {
            localVarQueryParameters['unitdp'] = ObjectSerializer.serialize(unitdp, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: BankTransactions;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "BankTransactions");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific attachment from a specific bank transaction by filename
     * @param xeroTenantId Xero identifier for Tenant
     * @param bankTransactionID Xero generated unique identifier for a bank transaction
     * @param fileName Name of the attachment
     * @param contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
     */     
    public async getBankTransactionAttachmentByFileName (xeroTenantId: string, bankTransactionID: string, fileName: string, contentType: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/BankTransactions/{BankTransactionID}/Attachments/{FileName}'
            .replace('{' + 'BankTransactionID' + '}', encodeURIComponent(String(bankTransactionID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/octet-stream"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getBankTransactionAttachmentByFileName.');
        }

        // verify required parameter 'bankTransactionID' is not null or undefined
        if (bankTransactionID === null || bankTransactionID === undefined) {
            throw new Error('Required parameter bankTransactionID was null or undefined when calling getBankTransactionAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling getBankTransactionAttachmentByFileName.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling getBankTransactionAttachmentByFileName.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['contentType'] = ObjectSerializer.serialize(contentType, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Buffer;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Buffer");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves specific attachments from a specific BankTransaction using a unique attachment Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param bankTransactionID Xero generated unique identifier for a bank transaction
     * @param attachmentID Unique identifier for Attachment object
     * @param contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
     */     
    public async getBankTransactionAttachmentById (xeroTenantId: string, bankTransactionID: string, attachmentID: string, contentType: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/BankTransactions/{BankTransactionID}/Attachments/{AttachmentID}'
            .replace('{' + 'BankTransactionID' + '}', encodeURIComponent(String(bankTransactionID)))
            .replace('{' + 'AttachmentID' + '}', encodeURIComponent(String(attachmentID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/octet-stream"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getBankTransactionAttachmentById.');
        }

        // verify required parameter 'bankTransactionID' is not null or undefined
        if (bankTransactionID === null || bankTransactionID === undefined) {
            throw new Error('Required parameter bankTransactionID was null or undefined when calling getBankTransactionAttachmentById.');
        }

        // verify required parameter 'attachmentID' is not null or undefined
        if (attachmentID === null || attachmentID === undefined) {
            throw new Error('Required parameter attachmentID was null or undefined when calling getBankTransactionAttachmentById.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling getBankTransactionAttachmentById.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['contentType'] = ObjectSerializer.serialize(contentType, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Buffer;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Buffer");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves any attachments from a specific bank transactions
     * @param xeroTenantId Xero identifier for Tenant
     * @param bankTransactionID Xero generated unique identifier for a bank transaction
     */     
    public async getBankTransactionAttachments (xeroTenantId: string, bankTransactionID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/BankTransactions/{BankTransactionID}/Attachments'
            .replace('{' + 'BankTransactionID' + '}', encodeURIComponent(String(bankTransactionID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getBankTransactionAttachments.');
        }

        // verify required parameter 'bankTransactionID' is not null or undefined
        if (bankTransactionID === null || bankTransactionID === undefined) {
            throw new Error('Required parameter bankTransactionID was null or undefined when calling getBankTransactionAttachments.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves any spent or received money transactions
     * @param xeroTenantId Xero identifier for Tenant
     * @param ifModifiedSince Only records created or modified since this timestamp will be returned
     * @param where Filter by an any element
     * @param order Order by an any element
     * @param page Up to 100 bank transactions will be returned in a single API call with line items details
     * @param unitdp e.g. unitdp&#x3D;4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
     * @param pageSize Number of records to retrieve per page
     */     
    public async getBankTransactions (xeroTenantId: string, ifModifiedSince?: Date, where?: string, order?: string, page?: number, unitdp?: number, pageSize?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: BankTransactions;  }> {
        const localVarPath = this.basePath + '/BankTransactions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getBankTransactions.');
        }

        if (where !== undefined) {
            localVarQueryParameters['where'] = ObjectSerializer.serialize(where, "string");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (unitdp !== undefined) {
            localVarQueryParameters['unitdp'] = ObjectSerializer.serialize(unitdp, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['If-Modified-Since'] = ObjectSerializer.serialize(ifModifiedSince, "Date");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: BankTransactions;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "BankTransactions");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves history from a specific bank transaction using a unique bank transaction Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param bankTransactionID Xero generated unique identifier for a bank transaction
     */     
    public async getBankTransactionsHistory (xeroTenantId: string, bankTransactionID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/BankTransactions/{BankTransactionID}/History'
            .replace('{' + 'BankTransactionID' + '}', encodeURIComponent(String(bankTransactionID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getBankTransactionsHistory.');
        }

        // verify required parameter 'bankTransactionID' is not null or undefined
        if (bankTransactionID === null || bankTransactionID === undefined) {
            throw new Error('Required parameter bankTransactionID was null or undefined when calling getBankTransactionsHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves specific bank transfers by using a unique bank transfer Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param bankTransferID Xero generated unique identifier for a bank transfer
     */     
    public async getBankTransfer (xeroTenantId: string, bankTransferID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: BankTransfers;  }> {
        const localVarPath = this.basePath + '/BankTransfers/{BankTransferID}'
            .replace('{' + 'BankTransferID' + '}', encodeURIComponent(String(bankTransferID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getBankTransfer.');
        }

        // verify required parameter 'bankTransferID' is not null or undefined
        if (bankTransferID === null || bankTransferID === undefined) {
            throw new Error('Required parameter bankTransferID was null or undefined when calling getBankTransfer.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: BankTransfers;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "BankTransfers");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific attachment on a specific bank transfer by file name
     * @param xeroTenantId Xero identifier for Tenant
     * @param bankTransferID Xero generated unique identifier for a bank transfer
     * @param fileName Name of the attachment
     * @param contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
     */     
    public async getBankTransferAttachmentByFileName (xeroTenantId: string, bankTransferID: string, fileName: string, contentType: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/BankTransfers/{BankTransferID}/Attachments/{FileName}'
            .replace('{' + 'BankTransferID' + '}', encodeURIComponent(String(bankTransferID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/octet-stream"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getBankTransferAttachmentByFileName.');
        }

        // verify required parameter 'bankTransferID' is not null or undefined
        if (bankTransferID === null || bankTransferID === undefined) {
            throw new Error('Required parameter bankTransferID was null or undefined when calling getBankTransferAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling getBankTransferAttachmentByFileName.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling getBankTransferAttachmentByFileName.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['contentType'] = ObjectSerializer.serialize(contentType, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Buffer;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Buffer");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific attachment from a specific bank transfer using a unique attachment ID
     * @param xeroTenantId Xero identifier for Tenant
     * @param bankTransferID Xero generated unique identifier for a bank transfer
     * @param attachmentID Unique identifier for Attachment object
     * @param contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
     */     
    public async getBankTransferAttachmentById (xeroTenantId: string, bankTransferID: string, attachmentID: string, contentType: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/BankTransfers/{BankTransferID}/Attachments/{AttachmentID}'
            .replace('{' + 'BankTransferID' + '}', encodeURIComponent(String(bankTransferID)))
            .replace('{' + 'AttachmentID' + '}', encodeURIComponent(String(attachmentID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/octet-stream"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getBankTransferAttachmentById.');
        }

        // verify required parameter 'bankTransferID' is not null or undefined
        if (bankTransferID === null || bankTransferID === undefined) {
            throw new Error('Required parameter bankTransferID was null or undefined when calling getBankTransferAttachmentById.');
        }

        // verify required parameter 'attachmentID' is not null or undefined
        if (attachmentID === null || attachmentID === undefined) {
            throw new Error('Required parameter attachmentID was null or undefined when calling getBankTransferAttachmentById.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling getBankTransferAttachmentById.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['contentType'] = ObjectSerializer.serialize(contentType, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Buffer;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Buffer");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves attachments from a specific bank transfer
     * @param xeroTenantId Xero identifier for Tenant
     * @param bankTransferID Xero generated unique identifier for a bank transfer
     */     
    public async getBankTransferAttachments (xeroTenantId: string, bankTransferID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/BankTransfers/{BankTransferID}/Attachments'
            .replace('{' + 'BankTransferID' + '}', encodeURIComponent(String(bankTransferID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getBankTransferAttachments.');
        }

        // verify required parameter 'bankTransferID' is not null or undefined
        if (bankTransferID === null || bankTransferID === undefined) {
            throw new Error('Required parameter bankTransferID was null or undefined when calling getBankTransferAttachments.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves history from a specific bank transfer using a unique bank transfer Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param bankTransferID Xero generated unique identifier for a bank transfer
     */     
    public async getBankTransferHistory (xeroTenantId: string, bankTransferID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/BankTransfers/{BankTransferID}/History'
            .replace('{' + 'BankTransferID' + '}', encodeURIComponent(String(bankTransferID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getBankTransferHistory.');
        }

        // verify required parameter 'bankTransferID' is not null or undefined
        if (bankTransferID === null || bankTransferID === undefined) {
            throw new Error('Required parameter bankTransferID was null or undefined when calling getBankTransferHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all bank transfers
     * @param xeroTenantId Xero identifier for Tenant
     * @param ifModifiedSince Only records created or modified since this timestamp will be returned
     * @param where Filter by an any element
     * @param order Order by an any element
     */     
    public async getBankTransfers (xeroTenantId: string, ifModifiedSince?: Date, where?: string, order?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: BankTransfers;  }> {
        const localVarPath = this.basePath + '/BankTransfers';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getBankTransfers.');
        }

        if (where !== undefined) {
            localVarQueryParameters['where'] = ObjectSerializer.serialize(where, "string");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['If-Modified-Since'] = ObjectSerializer.serialize(ifModifiedSince, "Date");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: BankTransfers;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "BankTransfers");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific batch payment using a unique batch payment Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param batchPaymentID Unique identifier for BatchPayment
     */     
    public async getBatchPayment (xeroTenantId: string, batchPaymentID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: BatchPayments;  }> {
        const localVarPath = this.basePath + '/BatchPayments/{BatchPaymentID}'
            .replace('{' + 'BatchPaymentID' + '}', encodeURIComponent(String(batchPaymentID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getBatchPayment.');
        }

        // verify required parameter 'batchPaymentID' is not null or undefined
        if (batchPaymentID === null || batchPaymentID === undefined) {
            throw new Error('Required parameter batchPaymentID was null or undefined when calling getBatchPayment.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: BatchPayments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "BatchPayments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves history from a specific batch payment
     * @param xeroTenantId Xero identifier for Tenant
     * @param batchPaymentID Unique identifier for BatchPayment
     */     
    public async getBatchPaymentHistory (xeroTenantId: string, batchPaymentID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/BatchPayments/{BatchPaymentID}/History'
            .replace('{' + 'BatchPaymentID' + '}', encodeURIComponent(String(batchPaymentID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getBatchPaymentHistory.');
        }

        // verify required parameter 'batchPaymentID' is not null or undefined
        if (batchPaymentID === null || batchPaymentID === undefined) {
            throw new Error('Required parameter batchPaymentID was null or undefined when calling getBatchPaymentHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves either one or many batch payments for invoices
     * @param xeroTenantId Xero identifier for Tenant
     * @param ifModifiedSince Only records created or modified since this timestamp will be returned
     * @param where Filter by an any element
     * @param order Order by an any element
     */     
    public async getBatchPayments (xeroTenantId: string, ifModifiedSince?: Date, where?: string, order?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: BatchPayments;  }> {
        const localVarPath = this.basePath + '/BatchPayments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getBatchPayments.');
        }

        if (where !== undefined) {
            localVarQueryParameters['where'] = ObjectSerializer.serialize(where, "string");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['If-Modified-Since'] = ObjectSerializer.serialize(ifModifiedSince, "Date");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: BatchPayments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "BatchPayments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific branding theme using a unique branding theme Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param brandingThemeID Unique identifier for a Branding Theme
     */     
    public async getBrandingTheme (xeroTenantId: string, brandingThemeID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: BrandingThemes;  }> {
        const localVarPath = this.basePath + '/BrandingThemes/{BrandingThemeID}'
            .replace('{' + 'BrandingThemeID' + '}', encodeURIComponent(String(brandingThemeID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getBrandingTheme.');
        }

        // verify required parameter 'brandingThemeID' is not null or undefined
        if (brandingThemeID === null || brandingThemeID === undefined) {
            throw new Error('Required parameter brandingThemeID was null or undefined when calling getBrandingTheme.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: BrandingThemes;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "BrandingThemes");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the payment services for a specific branding theme
     * @param xeroTenantId Xero identifier for Tenant
     * @param brandingThemeID Unique identifier for a Branding Theme
     */     
    public async getBrandingThemePaymentServices (xeroTenantId: string, brandingThemeID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: PaymentServices;  }> {
        const localVarPath = this.basePath + '/BrandingThemes/{BrandingThemeID}/PaymentServices'
            .replace('{' + 'BrandingThemeID' + '}', encodeURIComponent(String(brandingThemeID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getBrandingThemePaymentServices.');
        }

        // verify required parameter 'brandingThemeID' is not null or undefined
        if (brandingThemeID === null || brandingThemeID === undefined) {
            throw new Error('Required parameter brandingThemeID was null or undefined when calling getBrandingThemePaymentServices.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: PaymentServices;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "PaymentServices");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all the branding themes
     * @param xeroTenantId Xero identifier for Tenant
     */     
    public async getBrandingThemes (xeroTenantId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: BrandingThemes;  }> {
        const localVarPath = this.basePath + '/BrandingThemes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getBrandingThemes.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: BrandingThemes;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "BrandingThemes");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific budget, which includes budget lines
     * @param xeroTenantId Xero identifier for Tenant
     * @param budgetID Unique identifier for Budgets
     * @param dateTo Filter by start date
     * @param dateFrom Filter by end date
     */     
    public async getBudget (xeroTenantId: string, budgetID: string, dateTo?: string, dateFrom?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Budgets;  }> {
        const localVarPath = this.basePath + '/Budgets/{BudgetID}'
            .replace('{' + 'BudgetID' + '}', encodeURIComponent(String(budgetID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getBudget.');
        }

        // verify required parameter 'budgetID' is not null or undefined
        if (budgetID === null || budgetID === undefined) {
            throw new Error('Required parameter budgetID was null or undefined when calling getBudget.');
        }

        if (dateTo !== undefined) {
            localVarQueryParameters['DateTo'] = ObjectSerializer.serialize(dateTo, "string");
        }

        if (dateFrom !== undefined) {
            localVarQueryParameters['DateFrom'] = ObjectSerializer.serialize(dateFrom, "string");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Budgets;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Budgets");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve a list of budgets
     * @param xeroTenantId Xero identifier for Tenant
     * @param iDs Filter by BudgetID. Allows you to retrieve a specific individual budget.
     * @param dateTo Filter by start date
     * @param dateFrom Filter by end date
     */     
    public async getBudgets (xeroTenantId: string, iDs?: Array<string>, dateTo?: string, dateFrom?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Budgets;  }> {
        const localVarPath = this.basePath + '/Budgets';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getBudgets.');
        }

        if (iDs !== undefined) {
            localVarQueryParameters['IDs'] = ObjectSerializer.serialize(iDs, "Array<string>");
        }

        if (dateTo !== undefined) {
            localVarQueryParameters['DateTo'] = ObjectSerializer.serialize(dateTo, "string");
        }

        if (dateFrom !== undefined) {
            localVarQueryParameters['DateFrom'] = ObjectSerializer.serialize(dateFrom, "string");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Budgets;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Budgets");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific contacts in a Xero organisation using a unique contact Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param contactID Unique identifier for a Contact
     */     
    public async getContact (xeroTenantId: string, contactID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Contacts;  }> {
        const localVarPath = this.basePath + '/Contacts/{ContactID}'
            .replace('{' + 'ContactID' + '}', encodeURIComponent(String(contactID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getContact.');
        }

        // verify required parameter 'contactID' is not null or undefined
        if (contactID === null || contactID === undefined) {
            throw new Error('Required parameter contactID was null or undefined when calling getContact.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Contacts;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Contacts");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific attachment from a specific contact by file name
     * @param xeroTenantId Xero identifier for Tenant
     * @param contactID Unique identifier for a Contact
     * @param fileName Name of the attachment
     * @param contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
     */     
    public async getContactAttachmentByFileName (xeroTenantId: string, contactID: string, fileName: string, contentType: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/Contacts/{ContactID}/Attachments/{FileName}'
            .replace('{' + 'ContactID' + '}', encodeURIComponent(String(contactID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/octet-stream"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getContactAttachmentByFileName.');
        }

        // verify required parameter 'contactID' is not null or undefined
        if (contactID === null || contactID === undefined) {
            throw new Error('Required parameter contactID was null or undefined when calling getContactAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling getContactAttachmentByFileName.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling getContactAttachmentByFileName.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['contentType'] = ObjectSerializer.serialize(contentType, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Buffer;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Buffer");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific attachment from a specific contact using a unique attachment Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param contactID Unique identifier for a Contact
     * @param attachmentID Unique identifier for Attachment object
     * @param contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
     */     
    public async getContactAttachmentById (xeroTenantId: string, contactID: string, attachmentID: string, contentType: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/Contacts/{ContactID}/Attachments/{AttachmentID}'
            .replace('{' + 'ContactID' + '}', encodeURIComponent(String(contactID)))
            .replace('{' + 'AttachmentID' + '}', encodeURIComponent(String(attachmentID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/octet-stream"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getContactAttachmentById.');
        }

        // verify required parameter 'contactID' is not null or undefined
        if (contactID === null || contactID === undefined) {
            throw new Error('Required parameter contactID was null or undefined when calling getContactAttachmentById.');
        }

        // verify required parameter 'attachmentID' is not null or undefined
        if (attachmentID === null || attachmentID === undefined) {
            throw new Error('Required parameter attachmentID was null or undefined when calling getContactAttachmentById.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling getContactAttachmentById.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['contentType'] = ObjectSerializer.serialize(contentType, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Buffer;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Buffer");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves attachments for a specific contact in a Xero organisation
     * @param xeroTenantId Xero identifier for Tenant
     * @param contactID Unique identifier for a Contact
     */     
    public async getContactAttachments (xeroTenantId: string, contactID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/Contacts/{ContactID}/Attachments'
            .replace('{' + 'ContactID' + '}', encodeURIComponent(String(contactID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getContactAttachments.');
        }

        // verify required parameter 'contactID' is not null or undefined
        if (contactID === null || contactID === undefined) {
            throw new Error('Required parameter contactID was null or undefined when calling getContactAttachments.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific contact by contact number in a Xero organisation
     * @param xeroTenantId Xero identifier for Tenant
     * @param contactNumber This field is read only on the Xero contact screen, used to identify contacts in external systems (max length &#x3D; 50).
     */     
    public async getContactByContactNumber (xeroTenantId: string, contactNumber: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Contacts;  }> {
        const localVarPath = this.basePath + '/Contacts/{ContactNumber}'
            .replace('{' + 'ContactNumber' + '}', encodeURIComponent(String(contactNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getContactByContactNumber.');
        }

        // verify required parameter 'contactNumber' is not null or undefined
        if (contactNumber === null || contactNumber === undefined) {
            throw new Error('Required parameter contactNumber was null or undefined when calling getContactByContactNumber.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Contacts;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Contacts");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves CIS settings for a specific contact in a Xero organisation
     * @param xeroTenantId Xero identifier for Tenant
     * @param contactID Unique identifier for a Contact
     */     
    public async getContactCISSettings (xeroTenantId: string, contactID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: CISSettings;  }> {
        const localVarPath = this.basePath + '/Contacts/{ContactID}/CISSettings'
            .replace('{' + 'ContactID' + '}', encodeURIComponent(String(contactID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getContactCISSettings.');
        }

        // verify required parameter 'contactID' is not null or undefined
        if (contactID === null || contactID === undefined) {
            throw new Error('Required parameter contactID was null or undefined when calling getContactCISSettings.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: CISSettings;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "CISSettings");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific contact group by using a unique contact group Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param contactGroupID Unique identifier for a Contact Group
     */     
    public async getContactGroup (xeroTenantId: string, contactGroupID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: ContactGroups;  }> {
        const localVarPath = this.basePath + '/ContactGroups/{ContactGroupID}'
            .replace('{' + 'ContactGroupID' + '}', encodeURIComponent(String(contactGroupID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getContactGroup.');
        }

        // verify required parameter 'contactGroupID' is not null or undefined
        if (contactGroupID === null || contactGroupID === undefined) {
            throw new Error('Required parameter contactGroupID was null or undefined when calling getContactGroup.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: ContactGroups;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "ContactGroups");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the contact Id and name of each contact group
     * @param xeroTenantId Xero identifier for Tenant
     * @param where Filter by an any element
     * @param order Order by an any element
     */     
    public async getContactGroups (xeroTenantId: string, where?: string, order?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: ContactGroups;  }> {
        const localVarPath = this.basePath + '/ContactGroups';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getContactGroups.');
        }

        if (where !== undefined) {
            localVarQueryParameters['where'] = ObjectSerializer.serialize(where, "string");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: ContactGroups;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "ContactGroups");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves history records for a specific contact
     * @param xeroTenantId Xero identifier for Tenant
     * @param contactID Unique identifier for a Contact
     */     
    public async getContactHistory (xeroTenantId: string, contactID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/Contacts/{ContactID}/History'
            .replace('{' + 'ContactID' + '}', encodeURIComponent(String(contactID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getContactHistory.');
        }

        // verify required parameter 'contactID' is not null or undefined
        if (contactID === null || contactID === undefined) {
            throw new Error('Required parameter contactID was null or undefined when calling getContactHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves all contacts in a Xero organisation
     * @param xeroTenantId Xero identifier for Tenant
     * @param ifModifiedSince Only records created or modified since this timestamp will be returned
     * @param where Filter by an any element
     * @param order Order by an any element
     * @param iDs Filter by a comma separated list of ContactIDs. Allows you to retrieve a specific set of contacts in a single call.
     * @param page e.g. page&#x3D;1 - Up to 100 contacts will be returned in a single API call.
     * @param includeArchived e.g. includeArchived&#x3D;true - Contacts with a status of ARCHIVED will be included in the response
     * @param summaryOnly Use summaryOnly&#x3D;true in GET Contacts and Invoices endpoint to retrieve a smaller version of the response object. This returns only lightweight fields, excluding computation-heavy fields from the response, making the API calls quick and efficient.
     * @param searchTerm Search parameter that performs a case-insensitive text search across the Name, FirstName, LastName, ContactNumber and EmailAddress fields.
     * @param pageSize Number of records to retrieve per page
     */     
    public async getContacts (xeroTenantId: string, ifModifiedSince?: Date, where?: string, order?: string, iDs?: Array<string>, page?: number, includeArchived?: boolean, summaryOnly?: boolean, searchTerm?: string, pageSize?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Contacts;  }> {
        const localVarPath = this.basePath + '/Contacts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getContacts.');
        }

        if (where !== undefined) {
            localVarQueryParameters['where'] = ObjectSerializer.serialize(where, "string");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        if (iDs !== undefined) {
            localVarQueryParameters['IDs'] = ObjectSerializer.serialize(iDs, "Array<string>");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (includeArchived !== undefined) {
            localVarQueryParameters['includeArchived'] = ObjectSerializer.serialize(includeArchived, "boolean");
        }

        if (summaryOnly !== undefined) {
            localVarQueryParameters['summaryOnly'] = ObjectSerializer.serialize(summaryOnly, "boolean");
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['searchTerm'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['If-Modified-Since'] = ObjectSerializer.serialize(ifModifiedSince, "Date");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Contacts;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Contacts");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific credit note using a unique credit note Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param creditNoteID Unique identifier for a Credit Note
     * @param unitdp e.g. unitdp&#x3D;4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
     */     
    public async getCreditNote (xeroTenantId: string, creditNoteID: string, unitdp?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: CreditNotes;  }> {
        const localVarPath = this.basePath + '/CreditNotes/{CreditNoteID}'
            .replace('{' + 'CreditNoteID' + '}', encodeURIComponent(String(creditNoteID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getCreditNote.');
        }

        // verify required parameter 'creditNoteID' is not null or undefined
        if (creditNoteID === null || creditNoteID === undefined) {
            throw new Error('Required parameter creditNoteID was null or undefined when calling getCreditNote.');
        }

        if (unitdp !== undefined) {
            localVarQueryParameters['unitdp'] = ObjectSerializer.serialize(unitdp, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: CreditNotes;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "CreditNotes");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves credit notes as PDF files
     * @param xeroTenantId Xero identifier for Tenant
     * @param creditNoteID Unique identifier for a Credit Note
     */     
    public async getCreditNoteAsPdf (xeroTenantId: string, creditNoteID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/CreditNotes/{CreditNoteID}'
            .replace('{' + 'CreditNoteID' + '}', encodeURIComponent(String(creditNoteID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/pdf"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getCreditNoteAsPdf.');
        }

        // verify required parameter 'creditNoteID' is not null or undefined
        if (creditNoteID === null || creditNoteID === undefined) {
            throw new Error('Required parameter creditNoteID was null or undefined when calling getCreditNoteAsPdf.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Buffer;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Buffer");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific attachment on a specific credit note by file name
     * @param xeroTenantId Xero identifier for Tenant
     * @param creditNoteID Unique identifier for a Credit Note
     * @param fileName Name of the attachment
     * @param contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
     */     
    public async getCreditNoteAttachmentByFileName (xeroTenantId: string, creditNoteID: string, fileName: string, contentType: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/CreditNotes/{CreditNoteID}/Attachments/{FileName}'
            .replace('{' + 'CreditNoteID' + '}', encodeURIComponent(String(creditNoteID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/octet-stream"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getCreditNoteAttachmentByFileName.');
        }

        // verify required parameter 'creditNoteID' is not null or undefined
        if (creditNoteID === null || creditNoteID === undefined) {
            throw new Error('Required parameter creditNoteID was null or undefined when calling getCreditNoteAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling getCreditNoteAttachmentByFileName.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling getCreditNoteAttachmentByFileName.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['contentType'] = ObjectSerializer.serialize(contentType, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Buffer;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Buffer");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific attachment from a specific credit note using a unique attachment Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param creditNoteID Unique identifier for a Credit Note
     * @param attachmentID Unique identifier for Attachment object
     * @param contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
     */     
    public async getCreditNoteAttachmentById (xeroTenantId: string, creditNoteID: string, attachmentID: string, contentType: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/CreditNotes/{CreditNoteID}/Attachments/{AttachmentID}'
            .replace('{' + 'CreditNoteID' + '}', encodeURIComponent(String(creditNoteID)))
            .replace('{' + 'AttachmentID' + '}', encodeURIComponent(String(attachmentID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/octet-stream"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getCreditNoteAttachmentById.');
        }

        // verify required parameter 'creditNoteID' is not null or undefined
        if (creditNoteID === null || creditNoteID === undefined) {
            throw new Error('Required parameter creditNoteID was null or undefined when calling getCreditNoteAttachmentById.');
        }

        // verify required parameter 'attachmentID' is not null or undefined
        if (attachmentID === null || attachmentID === undefined) {
            throw new Error('Required parameter attachmentID was null or undefined when calling getCreditNoteAttachmentById.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling getCreditNoteAttachmentById.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['contentType'] = ObjectSerializer.serialize(contentType, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Buffer;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Buffer");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves attachments for a specific credit notes
     * @param xeroTenantId Xero identifier for Tenant
     * @param creditNoteID Unique identifier for a Credit Note
     */     
    public async getCreditNoteAttachments (xeroTenantId: string, creditNoteID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/CreditNotes/{CreditNoteID}/Attachments'
            .replace('{' + 'CreditNoteID' + '}', encodeURIComponent(String(creditNoteID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getCreditNoteAttachments.');
        }

        // verify required parameter 'creditNoteID' is not null or undefined
        if (creditNoteID === null || creditNoteID === undefined) {
            throw new Error('Required parameter creditNoteID was null or undefined when calling getCreditNoteAttachments.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves history records of a specific credit note
     * @param xeroTenantId Xero identifier for Tenant
     * @param creditNoteID Unique identifier for a Credit Note
     */     
    public async getCreditNoteHistory (xeroTenantId: string, creditNoteID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/CreditNotes/{CreditNoteID}/History'
            .replace('{' + 'CreditNoteID' + '}', encodeURIComponent(String(creditNoteID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getCreditNoteHistory.');
        }

        // verify required parameter 'creditNoteID' is not null or undefined
        if (creditNoteID === null || creditNoteID === undefined) {
            throw new Error('Required parameter creditNoteID was null or undefined when calling getCreditNoteHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves any credit notes
     * @param xeroTenantId Xero identifier for Tenant
     * @param ifModifiedSince Only records created or modified since this timestamp will be returned
     * @param where Filter by an any element
     * @param order Order by an any element
     * @param page e.g. page&#x3D;1 – Up to 100 credit notes will be returned in a single API call with line items shown for each credit note
     * @param unitdp e.g. unitdp&#x3D;4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
     * @param pageSize Number of records to retrieve per page
     */     
    public async getCreditNotes (xeroTenantId: string, ifModifiedSince?: Date, where?: string, order?: string, page?: number, unitdp?: number, pageSize?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: CreditNotes;  }> {
        const localVarPath = this.basePath + '/CreditNotes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getCreditNotes.');
        }

        if (where !== undefined) {
            localVarQueryParameters['where'] = ObjectSerializer.serialize(where, "string");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (unitdp !== undefined) {
            localVarQueryParameters['unitdp'] = ObjectSerializer.serialize(unitdp, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['If-Modified-Since'] = ObjectSerializer.serialize(ifModifiedSince, "Date");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: CreditNotes;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "CreditNotes");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves currencies for your Xero organisation
     * @param xeroTenantId Xero identifier for Tenant
     * @param where Filter by an any element
     * @param order Order by an any element
     */     
    public async getCurrencies (xeroTenantId: string, where?: string, order?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Currencies;  }> {
        const localVarPath = this.basePath + '/Currencies';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getCurrencies.');
        }

        if (where !== undefined) {
            localVarQueryParameters['where'] = ObjectSerializer.serialize(where, "string");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Currencies;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Currencies");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific employee used in Xero payrun using a unique employee Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param employeeID Unique identifier for a Employee
     */     
    public async getEmployee (xeroTenantId: string, employeeID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Employees;  }> {
        const localVarPath = this.basePath + '/Employees/{EmployeeID}'
            .replace('{' + 'EmployeeID' + '}', encodeURIComponent(String(employeeID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getEmployee.');
        }

        // verify required parameter 'employeeID' is not null or undefined
        if (employeeID === null || employeeID === undefined) {
            throw new Error('Required parameter employeeID was null or undefined when calling getEmployee.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Employees;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Employees");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves employees used in Xero payrun
     * @param xeroTenantId Xero identifier for Tenant
     * @param ifModifiedSince Only records created or modified since this timestamp will be returned
     * @param where Filter by an any element
     * @param order Order by an any element
     */     
    public async getEmployees (xeroTenantId: string, ifModifiedSince?: Date, where?: string, order?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Employees;  }> {
        const localVarPath = this.basePath + '/Employees';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getEmployees.');
        }

        if (where !== undefined) {
            localVarQueryParameters['where'] = ObjectSerializer.serialize(where, "string");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['If-Modified-Since'] = ObjectSerializer.serialize(ifModifiedSince, "Date");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Employees;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Employees");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific expense claim using a unique expense claim Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param expenseClaimID Unique identifier for a ExpenseClaim
     */     
    public async getExpenseClaim (xeroTenantId: string, expenseClaimID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: ExpenseClaims;  }> {
        const localVarPath = this.basePath + '/ExpenseClaims/{ExpenseClaimID}'
            .replace('{' + 'ExpenseClaimID' + '}', encodeURIComponent(String(expenseClaimID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getExpenseClaim.');
        }

        // verify required parameter 'expenseClaimID' is not null or undefined
        if (expenseClaimID === null || expenseClaimID === undefined) {
            throw new Error('Required parameter expenseClaimID was null or undefined when calling getExpenseClaim.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: ExpenseClaims;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "ExpenseClaims");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves history records of a specific expense claim
     * @param xeroTenantId Xero identifier for Tenant
     * @param expenseClaimID Unique identifier for a ExpenseClaim
     */     
    public async getExpenseClaimHistory (xeroTenantId: string, expenseClaimID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/ExpenseClaims/{ExpenseClaimID}/History'
            .replace('{' + 'ExpenseClaimID' + '}', encodeURIComponent(String(expenseClaimID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getExpenseClaimHistory.');
        }

        // verify required parameter 'expenseClaimID' is not null or undefined
        if (expenseClaimID === null || expenseClaimID === undefined) {
            throw new Error('Required parameter expenseClaimID was null or undefined when calling getExpenseClaimHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves expense claims
     * @param xeroTenantId Xero identifier for Tenant
     * @param ifModifiedSince Only records created or modified since this timestamp will be returned
     * @param where Filter by an any element
     * @param order Order by an any element
     */     
    public async getExpenseClaims (xeroTenantId: string, ifModifiedSince?: Date, where?: string, order?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: ExpenseClaims;  }> {
        const localVarPath = this.basePath + '/ExpenseClaims';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getExpenseClaims.');
        }

        if (where !== undefined) {
            localVarQueryParameters['where'] = ObjectSerializer.serialize(where, "string");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['If-Modified-Since'] = ObjectSerializer.serialize(ifModifiedSince, "Date");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: ExpenseClaims;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "ExpenseClaims");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific sales invoice or purchase bill using a unique invoice Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param invoiceID Unique identifier for an Invoice
     * @param unitdp e.g. unitdp&#x3D;4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
     */     
    public async getInvoice (xeroTenantId: string, invoiceID: string, unitdp?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Invoices;  }> {
        const localVarPath = this.basePath + '/Invoices/{InvoiceID}'
            .replace('{' + 'InvoiceID' + '}', encodeURIComponent(String(invoiceID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getInvoice.');
        }

        // verify required parameter 'invoiceID' is not null or undefined
        if (invoiceID === null || invoiceID === undefined) {
            throw new Error('Required parameter invoiceID was null or undefined when calling getInvoice.');
        }

        if (unitdp !== undefined) {
            localVarQueryParameters['unitdp'] = ObjectSerializer.serialize(unitdp, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Invoices;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Invoices");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves invoices or purchase bills as PDF files
     * @param xeroTenantId Xero identifier for Tenant
     * @param invoiceID Unique identifier for an Invoice
     */     
    public async getInvoiceAsPdf (xeroTenantId: string, invoiceID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/Invoices/{InvoiceID}'
            .replace('{' + 'InvoiceID' + '}', encodeURIComponent(String(invoiceID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/pdf"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getInvoiceAsPdf.');
        }

        // verify required parameter 'invoiceID' is not null or undefined
        if (invoiceID === null || invoiceID === undefined) {
            throw new Error('Required parameter invoiceID was null or undefined when calling getInvoiceAsPdf.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Buffer;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Buffer");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves an attachment from a specific invoice or purchase bill by filename
     * @param xeroTenantId Xero identifier for Tenant
     * @param invoiceID Unique identifier for an Invoice
     * @param fileName Name of the attachment
     * @param contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
     */     
    public async getInvoiceAttachmentByFileName (xeroTenantId: string, invoiceID: string, fileName: string, contentType: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/Invoices/{InvoiceID}/Attachments/{FileName}'
            .replace('{' + 'InvoiceID' + '}', encodeURIComponent(String(invoiceID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/octet-stream"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getInvoiceAttachmentByFileName.');
        }

        // verify required parameter 'invoiceID' is not null or undefined
        if (invoiceID === null || invoiceID === undefined) {
            throw new Error('Required parameter invoiceID was null or undefined when calling getInvoiceAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling getInvoiceAttachmentByFileName.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling getInvoiceAttachmentByFileName.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['contentType'] = ObjectSerializer.serialize(contentType, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Buffer;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Buffer");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific attachment from a specific invoices or purchase bills by using a unique attachment Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param invoiceID Unique identifier for an Invoice
     * @param attachmentID Unique identifier for Attachment object
     * @param contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
     */     
    public async getInvoiceAttachmentById (xeroTenantId: string, invoiceID: string, attachmentID: string, contentType: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/Invoices/{InvoiceID}/Attachments/{AttachmentID}'
            .replace('{' + 'InvoiceID' + '}', encodeURIComponent(String(invoiceID)))
            .replace('{' + 'AttachmentID' + '}', encodeURIComponent(String(attachmentID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/octet-stream"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getInvoiceAttachmentById.');
        }

        // verify required parameter 'invoiceID' is not null or undefined
        if (invoiceID === null || invoiceID === undefined) {
            throw new Error('Required parameter invoiceID was null or undefined when calling getInvoiceAttachmentById.');
        }

        // verify required parameter 'attachmentID' is not null or undefined
        if (attachmentID === null || attachmentID === undefined) {
            throw new Error('Required parameter attachmentID was null or undefined when calling getInvoiceAttachmentById.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling getInvoiceAttachmentById.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['contentType'] = ObjectSerializer.serialize(contentType, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Buffer;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Buffer");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves attachments for a specific invoice or purchase bill
     * @param xeroTenantId Xero identifier for Tenant
     * @param invoiceID Unique identifier for an Invoice
     */     
    public async getInvoiceAttachments (xeroTenantId: string, invoiceID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/Invoices/{InvoiceID}/Attachments'
            .replace('{' + 'InvoiceID' + '}', encodeURIComponent(String(invoiceID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getInvoiceAttachments.');
        }

        // verify required parameter 'invoiceID' is not null or undefined
        if (invoiceID === null || invoiceID === undefined) {
            throw new Error('Required parameter invoiceID was null or undefined when calling getInvoiceAttachments.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves history records for a specific invoice
     * @param xeroTenantId Xero identifier for Tenant
     * @param invoiceID Unique identifier for an Invoice
     */     
    public async getInvoiceHistory (xeroTenantId: string, invoiceID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/Invoices/{InvoiceID}/History'
            .replace('{' + 'InvoiceID' + '}', encodeURIComponent(String(invoiceID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getInvoiceHistory.');
        }

        // verify required parameter 'invoiceID' is not null or undefined
        if (invoiceID === null || invoiceID === undefined) {
            throw new Error('Required parameter invoiceID was null or undefined when calling getInvoiceHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves invoice reminder settings
     * @param xeroTenantId Xero identifier for Tenant
     */     
    public async getInvoiceReminders (xeroTenantId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: InvoiceReminders;  }> {
        const localVarPath = this.basePath + '/InvoiceReminders/Settings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getInvoiceReminders.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: InvoiceReminders;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "InvoiceReminders");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves sales invoices or purchase bills
     * @param xeroTenantId Xero identifier for Tenant
     * @param ifModifiedSince Only records created or modified since this timestamp will be returned
     * @param where Filter by an any element
     * @param order Order by an any element
     * @param iDs Filter by a comma-separated list of InvoicesIDs.
     * @param invoiceNumbers Filter by a comma-separated list of InvoiceNumbers.
     * @param contactIDs Filter by a comma-separated list of ContactIDs.
     * @param statuses Filter by a comma-separated list Statuses. For faster response times we recommend using these explicit parameters instead of passing OR conditions into the Where filter.
     * @param page e.g. page&#x3D;1 – Up to 100 invoices will be returned in a single API call with line items shown for each invoice
     * @param includeArchived e.g. includeArchived&#x3D;true - Invoices with a status of ARCHIVED will be included in the response
     * @param createdByMyApp When set to true you\&#39;ll only retrieve Invoices created by your app
     * @param unitdp e.g. unitdp&#x3D;4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
     * @param summaryOnly Use summaryOnly&#x3D;true in GET Contacts and Invoices endpoint to retrieve a smaller version of the response object. This returns only lightweight fields, excluding computation-heavy fields from the response, making the API calls quick and efficient.
     * @param pageSize Number of records to retrieve per page
     * @param searchTerm Search parameter that performs a case-insensitive text search across the fields e.g. InvoiceNumber, Reference.
     */     
    public async getInvoices (xeroTenantId: string, ifModifiedSince?: Date, where?: string, order?: string, iDs?: Array<string>, invoiceNumbers?: Array<string>, contactIDs?: Array<string>, statuses?: Array<string>, page?: number, includeArchived?: boolean, createdByMyApp?: boolean, unitdp?: number, summaryOnly?: boolean, pageSize?: number, searchTerm?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Invoices;  }> {
        const localVarPath = this.basePath + '/Invoices';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getInvoices.');
        }

        if (where !== undefined) {
            localVarQueryParameters['where'] = ObjectSerializer.serialize(where, "string");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        if (iDs !== undefined) {
            localVarQueryParameters['IDs'] = ObjectSerializer.serialize(iDs, "Array<string>");
        }

        if (invoiceNumbers !== undefined) {
            localVarQueryParameters['InvoiceNumbers'] = ObjectSerializer.serialize(invoiceNumbers, "Array<string>");
        }

        if (contactIDs !== undefined) {
            localVarQueryParameters['ContactIDs'] = ObjectSerializer.serialize(contactIDs, "Array<string>");
        }

        if (statuses !== undefined) {
            localVarQueryParameters['Statuses'] = ObjectSerializer.serialize(statuses, "Array<string>");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (includeArchived !== undefined) {
            localVarQueryParameters['includeArchived'] = ObjectSerializer.serialize(includeArchived, "boolean");
        }

        if (createdByMyApp !== undefined) {
            localVarQueryParameters['createdByMyApp'] = ObjectSerializer.serialize(createdByMyApp, "boolean");
        }

        if (unitdp !== undefined) {
            localVarQueryParameters['unitdp'] = ObjectSerializer.serialize(unitdp, "number");
        }

        if (summaryOnly !== undefined) {
            localVarQueryParameters['summaryOnly'] = ObjectSerializer.serialize(summaryOnly, "boolean");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (searchTerm !== undefined) {
            localVarQueryParameters['searchTerm'] = ObjectSerializer.serialize(searchTerm, "string");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['If-Modified-Since'] = ObjectSerializer.serialize(ifModifiedSince, "Date");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Invoices;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Invoices");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific item using a unique item Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param itemID Unique identifier for an Item
     * @param unitdp e.g. unitdp&#x3D;4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
     */     
    public async getItem (xeroTenantId: string, itemID: string, unitdp?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Items;  }> {
        const localVarPath = this.basePath + '/Items/{ItemID}'
            .replace('{' + 'ItemID' + '}', encodeURIComponent(String(itemID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getItem.');
        }

        // verify required parameter 'itemID' is not null or undefined
        if (itemID === null || itemID === undefined) {
            throw new Error('Required parameter itemID was null or undefined when calling getItem.');
        }

        if (unitdp !== undefined) {
            localVarQueryParameters['unitdp'] = ObjectSerializer.serialize(unitdp, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Items;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Items");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves history for a specific item
     * @param xeroTenantId Xero identifier for Tenant
     * @param itemID Unique identifier for an Item
     */     
    public async getItemHistory (xeroTenantId: string, itemID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/Items/{ItemID}/History'
            .replace('{' + 'ItemID' + '}', encodeURIComponent(String(itemID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getItemHistory.');
        }

        // verify required parameter 'itemID' is not null or undefined
        if (itemID === null || itemID === undefined) {
            throw new Error('Required parameter itemID was null or undefined when calling getItemHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves items
     * @param xeroTenantId Xero identifier for Tenant
     * @param ifModifiedSince Only records created or modified since this timestamp will be returned
     * @param where Filter by an any element
     * @param order Order by an any element
     * @param unitdp e.g. unitdp&#x3D;4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
     */     
    public async getItems (xeroTenantId: string, ifModifiedSince?: Date, where?: string, order?: string, unitdp?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Items;  }> {
        const localVarPath = this.basePath + '/Items';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getItems.');
        }

        if (where !== undefined) {
            localVarQueryParameters['where'] = ObjectSerializer.serialize(where, "string");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        if (unitdp !== undefined) {
            localVarQueryParameters['unitdp'] = ObjectSerializer.serialize(unitdp, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['If-Modified-Since'] = ObjectSerializer.serialize(ifModifiedSince, "Date");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Items;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Items");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific journal using a unique journal Id.
     * @param xeroTenantId Xero identifier for Tenant
     * @param journalID Unique identifier for a Journal
     */     
    public async getJournal (xeroTenantId: string, journalID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Journals;  }> {
        const localVarPath = this.basePath + '/Journals/{JournalID}'
            .replace('{' + 'JournalID' + '}', encodeURIComponent(String(journalID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getJournal.');
        }

        // verify required parameter 'journalID' is not null or undefined
        if (journalID === null || journalID === undefined) {
            throw new Error('Required parameter journalID was null or undefined when calling getJournal.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Journals;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Journals");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific journal using a unique journal number.
     * @param xeroTenantId Xero identifier for Tenant
     * @param journalNumber Number of a Journal
     */     
    public async getJournalByNumber (xeroTenantId: string, journalNumber: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Journals;  }> {
        const localVarPath = this.basePath + '/Journals/{JournalNumber}'
            .replace('{' + 'JournalNumber' + '}', encodeURIComponent(String(journalNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getJournalByNumber.');
        }

        // verify required parameter 'journalNumber' is not null or undefined
        if (journalNumber === null || journalNumber === undefined) {
            throw new Error('Required parameter journalNumber was null or undefined when calling getJournalByNumber.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Journals;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Journals");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves journals
     * @param xeroTenantId Xero identifier for Tenant
     * @param ifModifiedSince Only records created or modified since this timestamp will be returned
     * @param offset Offset by a specified journal number. e.g. journals with a JournalNumber greater than the offset will be returned
     * @param paymentsOnly Filter to retrieve journals on a cash basis. Journals are returned on an accrual basis by default.
     */     
    public async getJournals (xeroTenantId: string, ifModifiedSince?: Date, offset?: number, paymentsOnly?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Journals;  }> {
        const localVarPath = this.basePath + '/Journals';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getJournals.');
        }

        if (offset !== undefined) {
            localVarQueryParameters['offset'] = ObjectSerializer.serialize(offset, "number");
        }

        if (paymentsOnly !== undefined) {
            localVarQueryParameters['paymentsOnly'] = ObjectSerializer.serialize(paymentsOnly, "boolean");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['If-Modified-Since'] = ObjectSerializer.serialize(ifModifiedSince, "Date");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Journals;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Journals");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific linked transaction (billable expenses) using a unique linked transaction Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param linkedTransactionID Unique identifier for a LinkedTransaction
     */     
    public async getLinkedTransaction (xeroTenantId: string, linkedTransactionID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: LinkedTransactions;  }> {
        const localVarPath = this.basePath + '/LinkedTransactions/{LinkedTransactionID}'
            .replace('{' + 'LinkedTransactionID' + '}', encodeURIComponent(String(linkedTransactionID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getLinkedTransaction.');
        }

        // verify required parameter 'linkedTransactionID' is not null or undefined
        if (linkedTransactionID === null || linkedTransactionID === undefined) {
            throw new Error('Required parameter linkedTransactionID was null or undefined when calling getLinkedTransaction.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: LinkedTransactions;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "LinkedTransactions");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves linked transactions (billable expenses)
     * @param xeroTenantId Xero identifier for Tenant
     * @param page Up to 100 linked transactions will be returned in a single API call. Use the page parameter to specify the page to be returned e.g. page&#x3D;1.
     * @param linkedTransactionID The Xero identifier for an Linked Transaction
     * @param sourceTransactionID Filter by the SourceTransactionID. Get the linked transactions created from a particular ACCPAY invoice
     * @param contactID Filter by the ContactID. Get all the linked transactions that have been assigned to a particular customer.
     * @param status Filter by the combination of ContactID and Status. Get  the linked transactions associated to a  customer and with a status
     * @param targetTransactionID Filter by the TargetTransactionID. Get all the linked transactions allocated to a particular ACCREC invoice
     */     
    public async getLinkedTransactions (xeroTenantId: string, page?: number, linkedTransactionID?: string, sourceTransactionID?: string, contactID?: string, status?: string, targetTransactionID?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: LinkedTransactions;  }> {
        const localVarPath = this.basePath + '/LinkedTransactions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getLinkedTransactions.');
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (linkedTransactionID !== undefined) {
            localVarQueryParameters['LinkedTransactionID'] = ObjectSerializer.serialize(linkedTransactionID, "string");
        }

        if (sourceTransactionID !== undefined) {
            localVarQueryParameters['SourceTransactionID'] = ObjectSerializer.serialize(sourceTransactionID, "string");
        }

        if (contactID !== undefined) {
            localVarQueryParameters['ContactID'] = ObjectSerializer.serialize(contactID, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['Status'] = ObjectSerializer.serialize(status, "string");
        }

        if (targetTransactionID !== undefined) {
            localVarQueryParameters['TargetTransactionID'] = ObjectSerializer.serialize(targetTransactionID, "string");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: LinkedTransactions;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "LinkedTransactions");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific manual journal
     * @param xeroTenantId Xero identifier for Tenant
     * @param manualJournalID Unique identifier for a ManualJournal
     */     
    public async getManualJournal (xeroTenantId: string, manualJournalID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: ManualJournals;  }> {
        const localVarPath = this.basePath + '/ManualJournals/{ManualJournalID}'
            .replace('{' + 'ManualJournalID' + '}', encodeURIComponent(String(manualJournalID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getManualJournal.');
        }

        // verify required parameter 'manualJournalID' is not null or undefined
        if (manualJournalID === null || manualJournalID === undefined) {
            throw new Error('Required parameter manualJournalID was null or undefined when calling getManualJournal.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: ManualJournals;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "ManualJournals");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific attachment from a specific manual journal by file name
     * @param xeroTenantId Xero identifier for Tenant
     * @param manualJournalID Unique identifier for a ManualJournal
     * @param fileName Name of the attachment
     * @param contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
     */     
    public async getManualJournalAttachmentByFileName (xeroTenantId: string, manualJournalID: string, fileName: string, contentType: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/ManualJournals/{ManualJournalID}/Attachments/{FileName}'
            .replace('{' + 'ManualJournalID' + '}', encodeURIComponent(String(manualJournalID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/octet-stream"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getManualJournalAttachmentByFileName.');
        }

        // verify required parameter 'manualJournalID' is not null or undefined
        if (manualJournalID === null || manualJournalID === undefined) {
            throw new Error('Required parameter manualJournalID was null or undefined when calling getManualJournalAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling getManualJournalAttachmentByFileName.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling getManualJournalAttachmentByFileName.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['contentType'] = ObjectSerializer.serialize(contentType, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Buffer;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Buffer");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Allows you to retrieve a specific attachment from a specific manual journal using a unique attachment Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param manualJournalID Unique identifier for a ManualJournal
     * @param attachmentID Unique identifier for Attachment object
     * @param contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
     */     
    public async getManualJournalAttachmentById (xeroTenantId: string, manualJournalID: string, attachmentID: string, contentType: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/ManualJournals/{ManualJournalID}/Attachments/{AttachmentID}'
            .replace('{' + 'ManualJournalID' + '}', encodeURIComponent(String(manualJournalID)))
            .replace('{' + 'AttachmentID' + '}', encodeURIComponent(String(attachmentID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/octet-stream"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getManualJournalAttachmentById.');
        }

        // verify required parameter 'manualJournalID' is not null or undefined
        if (manualJournalID === null || manualJournalID === undefined) {
            throw new Error('Required parameter manualJournalID was null or undefined when calling getManualJournalAttachmentById.');
        }

        // verify required parameter 'attachmentID' is not null or undefined
        if (attachmentID === null || attachmentID === undefined) {
            throw new Error('Required parameter attachmentID was null or undefined when calling getManualJournalAttachmentById.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling getManualJournalAttachmentById.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['contentType'] = ObjectSerializer.serialize(contentType, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Buffer;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Buffer");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves attachment for a specific manual journal
     * @param xeroTenantId Xero identifier for Tenant
     * @param manualJournalID Unique identifier for a ManualJournal
     */     
    public async getManualJournalAttachments (xeroTenantId: string, manualJournalID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/ManualJournals/{ManualJournalID}/Attachments'
            .replace('{' + 'ManualJournalID' + '}', encodeURIComponent(String(manualJournalID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getManualJournalAttachments.');
        }

        // verify required parameter 'manualJournalID' is not null or undefined
        if (manualJournalID === null || manualJournalID === undefined) {
            throw new Error('Required parameter manualJournalID was null or undefined when calling getManualJournalAttachments.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves manual journals
     * @param xeroTenantId Xero identifier for Tenant
     * @param ifModifiedSince Only records created or modified since this timestamp will be returned
     * @param where Filter by an any element
     * @param order Order by an any element
     * @param page e.g. page&#x3D;1 – Up to 100 manual journals will be returned in a single API call with line items shown for each overpayment
     * @param pageSize Number of records to retrieve per page
     */     
    public async getManualJournals (xeroTenantId: string, ifModifiedSince?: Date, where?: string, order?: string, page?: number, pageSize?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: ManualJournals;  }> {
        const localVarPath = this.basePath + '/ManualJournals';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getManualJournals.');
        }

        if (where !== undefined) {
            localVarQueryParameters['where'] = ObjectSerializer.serialize(where, "string");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['If-Modified-Since'] = ObjectSerializer.serialize(ifModifiedSince, "Date");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: ManualJournals;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "ManualJournals");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves history for a specific manual journal
     * @param xeroTenantId Xero identifier for Tenant
     * @param manualJournalID Unique identifier for a ManualJournal
     */     
    public async getManualJournalsHistory (xeroTenantId: string, manualJournalID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/ManualJournals/{ManualJournalID}/History'
            .replace('{' + 'ManualJournalID' + '}', encodeURIComponent(String(manualJournalID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getManualJournalsHistory.');
        }

        // verify required parameter 'manualJournalID' is not null or undefined
        if (manualJournalID === null || manualJournalID === undefined) {
            throw new Error('Required parameter manualJournalID was null or undefined when calling getManualJournalsHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a URL to an online invoice
     * @param xeroTenantId Xero identifier for Tenant
     * @param invoiceID Unique identifier for an Invoice
     */     
    public async getOnlineInvoice (xeroTenantId: string, invoiceID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: OnlineInvoices;  }> {
        const localVarPath = this.basePath + '/Invoices/{InvoiceID}/OnlineInvoice'
            .replace('{' + 'InvoiceID' + '}', encodeURIComponent(String(invoiceID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getOnlineInvoice.');
        }

        // verify required parameter 'invoiceID' is not null or undefined
        if (invoiceID === null || invoiceID === undefined) {
            throw new Error('Required parameter invoiceID was null or undefined when calling getOnlineInvoice.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: OnlineInvoices;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "OnlineInvoices");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a list of the key actions your app has permission to perform in the connected Xero organisation.
     * @param xeroTenantId Xero identifier for Tenant
     */     
    public async getOrganisationActions (xeroTenantId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Actions;  }> {
        const localVarPath = this.basePath + '/Organisation/Actions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getOrganisationActions.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Actions;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Actions");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves the CIS settings for the Xero organistaion.
     * @param xeroTenantId Xero identifier for Tenant
     * @param organisationID The unique Xero identifier for an organisation
     */     
    public async getOrganisationCISSettings (xeroTenantId: string, organisationID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: CISOrgSettings;  }> {
        const localVarPath = this.basePath + '/Organisation/{OrganisationID}/CISSettings'
            .replace('{' + 'OrganisationID' + '}', encodeURIComponent(String(organisationID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getOrganisationCISSettings.');
        }

        // verify required parameter 'organisationID' is not null or undefined
        if (organisationID === null || organisationID === undefined) {
            throw new Error('Required parameter organisationID was null or undefined when calling getOrganisationCISSettings.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: CISOrgSettings;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "CISOrgSettings");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves Xero organisation details
     * @param xeroTenantId Xero identifier for Tenant
     */     
    public async getOrganisations (xeroTenantId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Organisations;  }> {
        const localVarPath = this.basePath + '/Organisation';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getOrganisations.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Organisations;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Organisations");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific overpayment using a unique overpayment Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param overpaymentID Unique identifier for a Overpayment
     */     
    public async getOverpayment (xeroTenantId: string, overpaymentID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Overpayments;  }> {
        const localVarPath = this.basePath + '/Overpayments/{OverpaymentID}'
            .replace('{' + 'OverpaymentID' + '}', encodeURIComponent(String(overpaymentID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getOverpayment.');
        }

        // verify required parameter 'overpaymentID' is not null or undefined
        if (overpaymentID === null || overpaymentID === undefined) {
            throw new Error('Required parameter overpaymentID was null or undefined when calling getOverpayment.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Overpayments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Overpayments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves history records of a specific overpayment
     * @param xeroTenantId Xero identifier for Tenant
     * @param overpaymentID Unique identifier for a Overpayment
     */     
    public async getOverpaymentHistory (xeroTenantId: string, overpaymentID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/Overpayments/{OverpaymentID}/History'
            .replace('{' + 'OverpaymentID' + '}', encodeURIComponent(String(overpaymentID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getOverpaymentHistory.');
        }

        // verify required parameter 'overpaymentID' is not null or undefined
        if (overpaymentID === null || overpaymentID === undefined) {
            throw new Error('Required parameter overpaymentID was null or undefined when calling getOverpaymentHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves overpayments
     * @param xeroTenantId Xero identifier for Tenant
     * @param ifModifiedSince Only records created or modified since this timestamp will be returned
     * @param where Filter by an any element
     * @param order Order by an any element
     * @param page e.g. page&#x3D;1 – Up to 100 overpayments will be returned in a single API call with line items shown for each overpayment
     * @param unitdp e.g. unitdp&#x3D;4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
     * @param pageSize Number of records to retrieve per page
     */     
    public async getOverpayments (xeroTenantId: string, ifModifiedSince?: Date, where?: string, order?: string, page?: number, unitdp?: number, pageSize?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Overpayments;  }> {
        const localVarPath = this.basePath + '/Overpayments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getOverpayments.');
        }

        if (where !== undefined) {
            localVarQueryParameters['where'] = ObjectSerializer.serialize(where, "string");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (unitdp !== undefined) {
            localVarQueryParameters['unitdp'] = ObjectSerializer.serialize(unitdp, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['If-Modified-Since'] = ObjectSerializer.serialize(ifModifiedSince, "Date");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Overpayments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Overpayments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific payment for invoices and credit notes using a unique payment Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param paymentID Unique identifier for a Payment
     */     
    public async getPayment (xeroTenantId: string, paymentID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Payments;  }> {
        const localVarPath = this.basePath + '/Payments/{PaymentID}'
            .replace('{' + 'PaymentID' + '}', encodeURIComponent(String(paymentID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getPayment.');
        }

        // verify required parameter 'paymentID' is not null or undefined
        if (paymentID === null || paymentID === undefined) {
            throw new Error('Required parameter paymentID was null or undefined when calling getPayment.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Payments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Payments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves history records of a specific payment
     * @param xeroTenantId Xero identifier for Tenant
     * @param paymentID Unique identifier for a Payment
     */     
    public async getPaymentHistory (xeroTenantId: string, paymentID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/Payments/{PaymentID}/History'
            .replace('{' + 'PaymentID' + '}', encodeURIComponent(String(paymentID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getPaymentHistory.');
        }

        // verify required parameter 'paymentID' is not null or undefined
        if (paymentID === null || paymentID === undefined) {
            throw new Error('Required parameter paymentID was null or undefined when calling getPaymentHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves payment services
     * @param xeroTenantId Xero identifier for Tenant
     */     
    public async getPaymentServices (xeroTenantId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: PaymentServices;  }> {
        const localVarPath = this.basePath + '/PaymentServices';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getPaymentServices.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: PaymentServices;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "PaymentServices");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves payments for invoices and credit notes
     * @param xeroTenantId Xero identifier for Tenant
     * @param ifModifiedSince Only records created or modified since this timestamp will be returned
     * @param where Filter by an any element
     * @param order Order by an any element
     * @param page Up to 100 payments will be returned in a single API call
     * @param pageSize Number of records to retrieve per page
     */     
    public async getPayments (xeroTenantId: string, ifModifiedSince?: Date, where?: string, order?: string, page?: number, pageSize?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Payments;  }> {
        const localVarPath = this.basePath + '/Payments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getPayments.');
        }

        if (where !== undefined) {
            localVarQueryParameters['where'] = ObjectSerializer.serialize(where, "string");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['If-Modified-Since'] = ObjectSerializer.serialize(ifModifiedSince, "Date");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Payments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Payments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Allows you to retrieve a specified prepayments
     * @param xeroTenantId Xero identifier for Tenant
     * @param prepaymentID Unique identifier for a PrePayment
     */     
    public async getPrepayment (xeroTenantId: string, prepaymentID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Prepayments;  }> {
        const localVarPath = this.basePath + '/Prepayments/{PrepaymentID}'
            .replace('{' + 'PrepaymentID' + '}', encodeURIComponent(String(prepaymentID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getPrepayment.');
        }

        // verify required parameter 'prepaymentID' is not null or undefined
        if (prepaymentID === null || prepaymentID === undefined) {
            throw new Error('Required parameter prepaymentID was null or undefined when calling getPrepayment.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Prepayments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Prepayments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves history record for a specific prepayment
     * @param xeroTenantId Xero identifier for Tenant
     * @param prepaymentID Unique identifier for a PrePayment
     */     
    public async getPrepaymentHistory (xeroTenantId: string, prepaymentID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/Prepayments/{PrepaymentID}/History'
            .replace('{' + 'PrepaymentID' + '}', encodeURIComponent(String(prepaymentID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getPrepaymentHistory.');
        }

        // verify required parameter 'prepaymentID' is not null or undefined
        if (prepaymentID === null || prepaymentID === undefined) {
            throw new Error('Required parameter prepaymentID was null or undefined when calling getPrepaymentHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves prepayments
     * @param xeroTenantId Xero identifier for Tenant
     * @param ifModifiedSince Only records created or modified since this timestamp will be returned
     * @param where Filter by an any element
     * @param order Order by an any element
     * @param page e.g. page&#x3D;1 – Up to 100 prepayments will be returned in a single API call with line items shown for each overpayment
     * @param unitdp e.g. unitdp&#x3D;4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
     * @param pageSize Number of records to retrieve per page
     */     
    public async getPrepayments (xeroTenantId: string, ifModifiedSince?: Date, where?: string, order?: string, page?: number, unitdp?: number, pageSize?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Prepayments;  }> {
        const localVarPath = this.basePath + '/Prepayments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getPrepayments.');
        }

        if (where !== undefined) {
            localVarQueryParameters['where'] = ObjectSerializer.serialize(where, "string");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (unitdp !== undefined) {
            localVarQueryParameters['unitdp'] = ObjectSerializer.serialize(unitdp, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['If-Modified-Since'] = ObjectSerializer.serialize(ifModifiedSince, "Date");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Prepayments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Prepayments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific purchase order using a unique purchase order Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param purchaseOrderID Unique identifier for an Purchase Order
     */     
    public async getPurchaseOrder (xeroTenantId: string, purchaseOrderID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: PurchaseOrders;  }> {
        const localVarPath = this.basePath + '/PurchaseOrders/{PurchaseOrderID}'
            .replace('{' + 'PurchaseOrderID' + '}', encodeURIComponent(String(purchaseOrderID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getPurchaseOrder.');
        }

        // verify required parameter 'purchaseOrderID' is not null or undefined
        if (purchaseOrderID === null || purchaseOrderID === undefined) {
            throw new Error('Required parameter purchaseOrderID was null or undefined when calling getPurchaseOrder.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: PurchaseOrders;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "PurchaseOrders");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves specific purchase order as PDF files using a unique purchase order Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param purchaseOrderID Unique identifier for an Purchase Order
     */     
    public async getPurchaseOrderAsPdf (xeroTenantId: string, purchaseOrderID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/PurchaseOrders/{PurchaseOrderID}'
            .replace('{' + 'PurchaseOrderID' + '}', encodeURIComponent(String(purchaseOrderID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/pdf"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getPurchaseOrderAsPdf.');
        }

        // verify required parameter 'purchaseOrderID' is not null or undefined
        if (purchaseOrderID === null || purchaseOrderID === undefined) {
            throw new Error('Required parameter purchaseOrderID was null or undefined when calling getPurchaseOrderAsPdf.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Buffer;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Buffer");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific attachment for a specific purchase order by filename
     * @param xeroTenantId Xero identifier for Tenant
     * @param purchaseOrderID Unique identifier for an Purchase Order
     * @param fileName Name of the attachment
     * @param contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
     */     
    public async getPurchaseOrderAttachmentByFileName (xeroTenantId: string, purchaseOrderID: string, fileName: string, contentType: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/PurchaseOrders/{PurchaseOrderID}/Attachments/{FileName}'
            .replace('{' + 'PurchaseOrderID' + '}', encodeURIComponent(String(purchaseOrderID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/octet-stream"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getPurchaseOrderAttachmentByFileName.');
        }

        // verify required parameter 'purchaseOrderID' is not null or undefined
        if (purchaseOrderID === null || purchaseOrderID === undefined) {
            throw new Error('Required parameter purchaseOrderID was null or undefined when calling getPurchaseOrderAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling getPurchaseOrderAttachmentByFileName.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling getPurchaseOrderAttachmentByFileName.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['contentType'] = ObjectSerializer.serialize(contentType, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Buffer;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Buffer");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves specific attachment for a specific purchase order using a unique attachment Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param purchaseOrderID Unique identifier for an Purchase Order
     * @param attachmentID Unique identifier for Attachment object
     * @param contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
     */     
    public async getPurchaseOrderAttachmentById (xeroTenantId: string, purchaseOrderID: string, attachmentID: string, contentType: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/PurchaseOrders/{PurchaseOrderID}/Attachments/{AttachmentID}'
            .replace('{' + 'PurchaseOrderID' + '}', encodeURIComponent(String(purchaseOrderID)))
            .replace('{' + 'AttachmentID' + '}', encodeURIComponent(String(attachmentID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/octet-stream"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getPurchaseOrderAttachmentById.');
        }

        // verify required parameter 'purchaseOrderID' is not null or undefined
        if (purchaseOrderID === null || purchaseOrderID === undefined) {
            throw new Error('Required parameter purchaseOrderID was null or undefined when calling getPurchaseOrderAttachmentById.');
        }

        // verify required parameter 'attachmentID' is not null or undefined
        if (attachmentID === null || attachmentID === undefined) {
            throw new Error('Required parameter attachmentID was null or undefined when calling getPurchaseOrderAttachmentById.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling getPurchaseOrderAttachmentById.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['contentType'] = ObjectSerializer.serialize(contentType, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Buffer;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Buffer");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves attachments for a specific purchase order
     * @param xeroTenantId Xero identifier for Tenant
     * @param purchaseOrderID Unique identifier for an Purchase Order
     */     
    public async getPurchaseOrderAttachments (xeroTenantId: string, purchaseOrderID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/PurchaseOrders/{PurchaseOrderID}/Attachments'
            .replace('{' + 'PurchaseOrderID' + '}', encodeURIComponent(String(purchaseOrderID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getPurchaseOrderAttachments.');
        }

        // verify required parameter 'purchaseOrderID' is not null or undefined
        if (purchaseOrderID === null || purchaseOrderID === undefined) {
            throw new Error('Required parameter purchaseOrderID was null or undefined when calling getPurchaseOrderAttachments.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific purchase order using purchase order number
     * @param xeroTenantId Xero identifier for Tenant
     * @param purchaseOrderNumber Unique identifier for a PurchaseOrder
     */     
    public async getPurchaseOrderByNumber (xeroTenantId: string, purchaseOrderNumber: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: PurchaseOrders;  }> {
        const localVarPath = this.basePath + '/PurchaseOrders/{PurchaseOrderNumber}'
            .replace('{' + 'PurchaseOrderNumber' + '}', encodeURIComponent(String(purchaseOrderNumber)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getPurchaseOrderByNumber.');
        }

        // verify required parameter 'purchaseOrderNumber' is not null or undefined
        if (purchaseOrderNumber === null || purchaseOrderNumber === undefined) {
            throw new Error('Required parameter purchaseOrderNumber was null or undefined when calling getPurchaseOrderByNumber.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: PurchaseOrders;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "PurchaseOrders");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves history for a specific purchase order
     * @param xeroTenantId Xero identifier for Tenant
     * @param purchaseOrderID Unique identifier for an Purchase Order
     */     
    public async getPurchaseOrderHistory (xeroTenantId: string, purchaseOrderID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/PurchaseOrders/{PurchaseOrderID}/History'
            .replace('{' + 'PurchaseOrderID' + '}', encodeURIComponent(String(purchaseOrderID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getPurchaseOrderHistory.');
        }

        // verify required parameter 'purchaseOrderID' is not null or undefined
        if (purchaseOrderID === null || purchaseOrderID === undefined) {
            throw new Error('Required parameter purchaseOrderID was null or undefined when calling getPurchaseOrderHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves purchase orders
     * @param xeroTenantId Xero identifier for Tenant
     * @param ifModifiedSince Only records created or modified since this timestamp will be returned
     * @param status Filter by purchase order status
     * @param dateFrom Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom&#x3D;2015-12-01&amp;DateTo&#x3D;2015-12-31
     * @param dateTo Filter by purchase order date (e.g. GET https://.../PurchaseOrders?DateFrom&#x3D;2015-12-01&amp;DateTo&#x3D;2015-12-31
     * @param order Order by an any element
     * @param page To specify a page, append the page parameter to the URL e.g. ?page&#x3D;1. If there are 100 records in the response you will need to check if there is any more data by fetching the next page e.g ?page&#x3D;2 and continuing this process until no more results are returned.
     * @param pageSize Number of records to retrieve per page
     */     
    public async getPurchaseOrders (xeroTenantId: string, ifModifiedSince?: Date, status?: 'DRAFT' | 'SUBMITTED' | 'AUTHORISED' | 'BILLED' | 'DELETED', dateFrom?: string, dateTo?: string, order?: string, page?: number, pageSize?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: PurchaseOrders;  }> {
        const localVarPath = this.basePath + '/PurchaseOrders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getPurchaseOrders.');
        }

        if (status !== undefined) {
            localVarQueryParameters['Status'] = ObjectSerializer.serialize(status, "'DRAFT' | 'SUBMITTED' | 'AUTHORISED' | 'BILLED' | 'DELETED'");
        }

        if (dateFrom !== undefined) {
            localVarQueryParameters['DateFrom'] = ObjectSerializer.serialize(dateFrom, "string");
        }

        if (dateTo !== undefined) {
            localVarQueryParameters['DateTo'] = ObjectSerializer.serialize(dateTo, "string");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['pageSize'] = ObjectSerializer.serialize(pageSize, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['If-Modified-Since'] = ObjectSerializer.serialize(ifModifiedSince, "Date");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: PurchaseOrders;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "PurchaseOrders");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific quote using a unique quote Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param quoteID Unique identifier for an Quote
     */     
    public async getQuote (xeroTenantId: string, quoteID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Quotes;  }> {
        const localVarPath = this.basePath + '/Quotes/{QuoteID}'
            .replace('{' + 'QuoteID' + '}', encodeURIComponent(String(quoteID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getQuote.');
        }

        // verify required parameter 'quoteID' is not null or undefined
        if (quoteID === null || quoteID === undefined) {
            throw new Error('Required parameter quoteID was null or undefined when calling getQuote.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Quotes;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Quotes");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific quote as a PDF file using a unique quote Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param quoteID Unique identifier for an Quote
     */     
    public async getQuoteAsPdf (xeroTenantId: string, quoteID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/Quotes/{QuoteID}'
            .replace('{' + 'QuoteID' + '}', encodeURIComponent(String(quoteID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/pdf"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getQuoteAsPdf.');
        }

        // verify required parameter 'quoteID' is not null or undefined
        if (quoteID === null || quoteID === undefined) {
            throw new Error('Required parameter quoteID was null or undefined when calling getQuoteAsPdf.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Buffer;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Buffer");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific attachment from a specific quote by filename
     * @param xeroTenantId Xero identifier for Tenant
     * @param quoteID Unique identifier for an Quote
     * @param fileName Name of the attachment
     * @param contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
     */     
    public async getQuoteAttachmentByFileName (xeroTenantId: string, quoteID: string, fileName: string, contentType: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/Quotes/{QuoteID}/Attachments/{FileName}'
            .replace('{' + 'QuoteID' + '}', encodeURIComponent(String(quoteID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/octet-stream"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getQuoteAttachmentByFileName.');
        }

        // verify required parameter 'quoteID' is not null or undefined
        if (quoteID === null || quoteID === undefined) {
            throw new Error('Required parameter quoteID was null or undefined when calling getQuoteAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling getQuoteAttachmentByFileName.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling getQuoteAttachmentByFileName.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['contentType'] = ObjectSerializer.serialize(contentType, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Buffer;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Buffer");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific attachment from a specific quote using a unique attachment Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param quoteID Unique identifier for an Quote
     * @param attachmentID Unique identifier for Attachment object
     * @param contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
     */     
    public async getQuoteAttachmentById (xeroTenantId: string, quoteID: string, attachmentID: string, contentType: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/Quotes/{QuoteID}/Attachments/{AttachmentID}'
            .replace('{' + 'QuoteID' + '}', encodeURIComponent(String(quoteID)))
            .replace('{' + 'AttachmentID' + '}', encodeURIComponent(String(attachmentID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/octet-stream"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getQuoteAttachmentById.');
        }

        // verify required parameter 'quoteID' is not null or undefined
        if (quoteID === null || quoteID === undefined) {
            throw new Error('Required parameter quoteID was null or undefined when calling getQuoteAttachmentById.');
        }

        // verify required parameter 'attachmentID' is not null or undefined
        if (attachmentID === null || attachmentID === undefined) {
            throw new Error('Required parameter attachmentID was null or undefined when calling getQuoteAttachmentById.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling getQuoteAttachmentById.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['contentType'] = ObjectSerializer.serialize(contentType, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Buffer;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Buffer");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves attachments for a specific quote
     * @param xeroTenantId Xero identifier for Tenant
     * @param quoteID Unique identifier for an Quote
     */     
    public async getQuoteAttachments (xeroTenantId: string, quoteID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/Quotes/{QuoteID}/Attachments'
            .replace('{' + 'QuoteID' + '}', encodeURIComponent(String(quoteID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getQuoteAttachments.');
        }

        // verify required parameter 'quoteID' is not null or undefined
        if (quoteID === null || quoteID === undefined) {
            throw new Error('Required parameter quoteID was null or undefined when calling getQuoteAttachments.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves history records of a specific quote
     * @param xeroTenantId Xero identifier for Tenant
     * @param quoteID Unique identifier for an Quote
     */     
    public async getQuoteHistory (xeroTenantId: string, quoteID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/Quotes/{QuoteID}/History'
            .replace('{' + 'QuoteID' + '}', encodeURIComponent(String(quoteID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getQuoteHistory.');
        }

        // verify required parameter 'quoteID' is not null or undefined
        if (quoteID === null || quoteID === undefined) {
            throw new Error('Required parameter quoteID was null or undefined when calling getQuoteHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves sales quotes
     * @param xeroTenantId Xero identifier for Tenant
     * @param ifModifiedSince Only records created or modified since this timestamp will be returned
     * @param dateFrom Filter for quotes after a particular date
     * @param dateTo Filter for quotes before a particular date
     * @param expiryDateFrom Filter for quotes expiring after a particular date
     * @param expiryDateTo Filter for quotes before a particular date
     * @param contactID Filter for quotes belonging to a particular contact
     * @param status Filter for quotes of a particular Status
     * @param page e.g. page&#x3D;1 – Up to 100 Quotes will be returned in a single API call with line items shown for each quote
     * @param order Order by an any element
     * @param quoteNumber Filter by quote number (e.g. GET https://.../Quotes?QuoteNumber&#x3D;QU-0001)
     */     
    public async getQuotes (xeroTenantId: string, ifModifiedSince?: Date, dateFrom?: string, dateTo?: string, expiryDateFrom?: string, expiryDateTo?: string, contactID?: string, status?: string, page?: number, order?: string, quoteNumber?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Quotes;  }> {
        const localVarPath = this.basePath + '/Quotes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getQuotes.');
        }

        if (dateFrom !== undefined) {
            localVarQueryParameters['DateFrom'] = ObjectSerializer.serialize(dateFrom, "string");
        }

        if (dateTo !== undefined) {
            localVarQueryParameters['DateTo'] = ObjectSerializer.serialize(dateTo, "string");
        }

        if (expiryDateFrom !== undefined) {
            localVarQueryParameters['ExpiryDateFrom'] = ObjectSerializer.serialize(expiryDateFrom, "string");
        }

        if (expiryDateTo !== undefined) {
            localVarQueryParameters['ExpiryDateTo'] = ObjectSerializer.serialize(expiryDateTo, "string");
        }

        if (contactID !== undefined) {
            localVarQueryParameters['ContactID'] = ObjectSerializer.serialize(contactID, "string");
        }

        if (status !== undefined) {
            localVarQueryParameters['Status'] = ObjectSerializer.serialize(status, "string");
        }

        if (page !== undefined) {
            localVarQueryParameters['page'] = ObjectSerializer.serialize(page, "number");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        if (quoteNumber !== undefined) {
            localVarQueryParameters['QuoteNumber'] = ObjectSerializer.serialize(quoteNumber, "string");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['If-Modified-Since'] = ObjectSerializer.serialize(ifModifiedSince, "Date");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Quotes;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Quotes");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific draft expense claim receipt by using a unique receipt Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param receiptID Unique identifier for a Receipt
     * @param unitdp e.g. unitdp&#x3D;4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
     */     
    public async getReceipt (xeroTenantId: string, receiptID: string, unitdp?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Receipts;  }> {
        const localVarPath = this.basePath + '/Receipts/{ReceiptID}'
            .replace('{' + 'ReceiptID' + '}', encodeURIComponent(String(receiptID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getReceipt.');
        }

        // verify required parameter 'receiptID' is not null or undefined
        if (receiptID === null || receiptID === undefined) {
            throw new Error('Required parameter receiptID was null or undefined when calling getReceipt.');
        }

        if (unitdp !== undefined) {
            localVarQueryParameters['unitdp'] = ObjectSerializer.serialize(unitdp, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Receipts;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Receipts");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific attachment from a specific expense claim receipts by file name
     * @param xeroTenantId Xero identifier for Tenant
     * @param receiptID Unique identifier for a Receipt
     * @param fileName Name of the attachment
     * @param contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
     */     
    public async getReceiptAttachmentByFileName (xeroTenantId: string, receiptID: string, fileName: string, contentType: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/Receipts/{ReceiptID}/Attachments/{FileName}'
            .replace('{' + 'ReceiptID' + '}', encodeURIComponent(String(receiptID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/octet-stream"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getReceiptAttachmentByFileName.');
        }

        // verify required parameter 'receiptID' is not null or undefined
        if (receiptID === null || receiptID === undefined) {
            throw new Error('Required parameter receiptID was null or undefined when calling getReceiptAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling getReceiptAttachmentByFileName.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling getReceiptAttachmentByFileName.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['contentType'] = ObjectSerializer.serialize(contentType, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Buffer;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Buffer");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific attachments from a specific expense claim receipts by using a unique attachment Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param receiptID Unique identifier for a Receipt
     * @param attachmentID Unique identifier for Attachment object
     * @param contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
     */     
    public async getReceiptAttachmentById (xeroTenantId: string, receiptID: string, attachmentID: string, contentType: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/Receipts/{ReceiptID}/Attachments/{AttachmentID}'
            .replace('{' + 'ReceiptID' + '}', encodeURIComponent(String(receiptID)))
            .replace('{' + 'AttachmentID' + '}', encodeURIComponent(String(attachmentID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/octet-stream"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getReceiptAttachmentById.');
        }

        // verify required parameter 'receiptID' is not null or undefined
        if (receiptID === null || receiptID === undefined) {
            throw new Error('Required parameter receiptID was null or undefined when calling getReceiptAttachmentById.');
        }

        // verify required parameter 'attachmentID' is not null or undefined
        if (attachmentID === null || attachmentID === undefined) {
            throw new Error('Required parameter attachmentID was null or undefined when calling getReceiptAttachmentById.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling getReceiptAttachmentById.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['contentType'] = ObjectSerializer.serialize(contentType, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Buffer;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Buffer");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves attachments for a specific expense claim receipt
     * @param xeroTenantId Xero identifier for Tenant
     * @param receiptID Unique identifier for a Receipt
     */     
    public async getReceiptAttachments (xeroTenantId: string, receiptID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/Receipts/{ReceiptID}/Attachments'
            .replace('{' + 'ReceiptID' + '}', encodeURIComponent(String(receiptID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getReceiptAttachments.');
        }

        // verify required parameter 'receiptID' is not null or undefined
        if (receiptID === null || receiptID === undefined) {
            throw new Error('Required parameter receiptID was null or undefined when calling getReceiptAttachments.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a history record for a specific receipt
     * @param xeroTenantId Xero identifier for Tenant
     * @param receiptID Unique identifier for a Receipt
     */     
    public async getReceiptHistory (xeroTenantId: string, receiptID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/Receipts/{ReceiptID}/History'
            .replace('{' + 'ReceiptID' + '}', encodeURIComponent(String(receiptID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getReceiptHistory.');
        }

        // verify required parameter 'receiptID' is not null or undefined
        if (receiptID === null || receiptID === undefined) {
            throw new Error('Required parameter receiptID was null or undefined when calling getReceiptHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves draft expense claim receipts for any user
     * @param xeroTenantId Xero identifier for Tenant
     * @param ifModifiedSince Only records created or modified since this timestamp will be returned
     * @param where Filter by an any element
     * @param order Order by an any element
     * @param unitdp e.g. unitdp&#x3D;4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
     */     
    public async getReceipts (xeroTenantId: string, ifModifiedSince?: Date, where?: string, order?: string, unitdp?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Receipts;  }> {
        const localVarPath = this.basePath + '/Receipts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getReceipts.');
        }

        if (where !== undefined) {
            localVarQueryParameters['where'] = ObjectSerializer.serialize(where, "string");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        if (unitdp !== undefined) {
            localVarQueryParameters['unitdp'] = ObjectSerializer.serialize(unitdp, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['If-Modified-Since'] = ObjectSerializer.serialize(ifModifiedSince, "Date");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Receipts;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Receipts");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific repeating invoice by using a unique repeating invoice Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param repeatingInvoiceID Unique identifier for a Repeating Invoice
     */     
    public async getRepeatingInvoice (xeroTenantId: string, repeatingInvoiceID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: RepeatingInvoices;  }> {
        const localVarPath = this.basePath + '/RepeatingInvoices/{RepeatingInvoiceID}'
            .replace('{' + 'RepeatingInvoiceID' + '}', encodeURIComponent(String(repeatingInvoiceID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getRepeatingInvoice.');
        }

        // verify required parameter 'repeatingInvoiceID' is not null or undefined
        if (repeatingInvoiceID === null || repeatingInvoiceID === undefined) {
            throw new Error('Required parameter repeatingInvoiceID was null or undefined when calling getRepeatingInvoice.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: RepeatingInvoices;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "RepeatingInvoices");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific attachment from a specific repeating invoices by file name
     * @param xeroTenantId Xero identifier for Tenant
     * @param repeatingInvoiceID Unique identifier for a Repeating Invoice
     * @param fileName Name of the attachment
     * @param contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
     */     
    public async getRepeatingInvoiceAttachmentByFileName (xeroTenantId: string, repeatingInvoiceID: string, fileName: string, contentType: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{FileName}'
            .replace('{' + 'RepeatingInvoiceID' + '}', encodeURIComponent(String(repeatingInvoiceID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/octet-stream"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getRepeatingInvoiceAttachmentByFileName.');
        }

        // verify required parameter 'repeatingInvoiceID' is not null or undefined
        if (repeatingInvoiceID === null || repeatingInvoiceID === undefined) {
            throw new Error('Required parameter repeatingInvoiceID was null or undefined when calling getRepeatingInvoiceAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling getRepeatingInvoiceAttachmentByFileName.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling getRepeatingInvoiceAttachmentByFileName.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['contentType'] = ObjectSerializer.serialize(contentType, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Buffer;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Buffer");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific attachment from a specific repeating invoice
     * @param xeroTenantId Xero identifier for Tenant
     * @param repeatingInvoiceID Unique identifier for a Repeating Invoice
     * @param attachmentID Unique identifier for Attachment object
     * @param contentType The mime type of the attachment file you are retrieving i.e image/jpg, application/pdf
     */     
    public async getRepeatingInvoiceAttachmentById (xeroTenantId: string, repeatingInvoiceID: string, attachmentID: string, contentType: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Buffer;  }> {
        const localVarPath = this.basePath + '/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{AttachmentID}'
            .replace('{' + 'RepeatingInvoiceID' + '}', encodeURIComponent(String(repeatingInvoiceID)))
            .replace('{' + 'AttachmentID' + '}', encodeURIComponent(String(attachmentID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/octet-stream"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getRepeatingInvoiceAttachmentById.');
        }

        // verify required parameter 'repeatingInvoiceID' is not null or undefined
        if (repeatingInvoiceID === null || repeatingInvoiceID === undefined) {
            throw new Error('Required parameter repeatingInvoiceID was null or undefined when calling getRepeatingInvoiceAttachmentById.');
        }

        // verify required parameter 'attachmentID' is not null or undefined
        if (attachmentID === null || attachmentID === undefined) {
            throw new Error('Required parameter attachmentID was null or undefined when calling getRepeatingInvoiceAttachmentById.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling getRepeatingInvoiceAttachmentById.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['contentType'] = ObjectSerializer.serialize(contentType, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Buffer;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Buffer");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves attachments from a specific repeating invoice
     * @param xeroTenantId Xero identifier for Tenant
     * @param repeatingInvoiceID Unique identifier for a Repeating Invoice
     */     
    public async getRepeatingInvoiceAttachments (xeroTenantId: string, repeatingInvoiceID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/RepeatingInvoices/{RepeatingInvoiceID}/Attachments'
            .replace('{' + 'RepeatingInvoiceID' + '}', encodeURIComponent(String(repeatingInvoiceID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getRepeatingInvoiceAttachments.');
        }

        // verify required parameter 'repeatingInvoiceID' is not null or undefined
        if (repeatingInvoiceID === null || repeatingInvoiceID === undefined) {
            throw new Error('Required parameter repeatingInvoiceID was null or undefined when calling getRepeatingInvoiceAttachments.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves history record for a specific repeating invoice
     * @param xeroTenantId Xero identifier for Tenant
     * @param repeatingInvoiceID Unique identifier for a Repeating Invoice
     */     
    public async getRepeatingInvoiceHistory (xeroTenantId: string, repeatingInvoiceID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: HistoryRecords;  }> {
        const localVarPath = this.basePath + '/RepeatingInvoices/{RepeatingInvoiceID}/History'
            .replace('{' + 'RepeatingInvoiceID' + '}', encodeURIComponent(String(repeatingInvoiceID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getRepeatingInvoiceHistory.');
        }

        // verify required parameter 'repeatingInvoiceID' is not null or undefined
        if (repeatingInvoiceID === null || repeatingInvoiceID === undefined) {
            throw new Error('Required parameter repeatingInvoiceID was null or undefined when calling getRepeatingInvoiceHistory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: HistoryRecords;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "HistoryRecords");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves repeating invoices
     * @param xeroTenantId Xero identifier for Tenant
     * @param where Filter by an any element
     * @param order Order by an any element
     */     
    public async getRepeatingInvoices (xeroTenantId: string, where?: string, order?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: RepeatingInvoices;  }> {
        const localVarPath = this.basePath + '/RepeatingInvoices';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getRepeatingInvoices.');
        }

        if (where !== undefined) {
            localVarQueryParameters['where'] = ObjectSerializer.serialize(where, "string");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: RepeatingInvoices;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "RepeatingInvoices");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves report for aged payables by contact
     * @param xeroTenantId Xero identifier for Tenant
     * @param contactId Unique identifier for a Contact
     * @param date The date of the Aged Payables By Contact report
     * @param fromDate filter by the from date of the report e.g. 2021-02-01
     * @param toDate filter by the to date of the report e.g. 2021-02-28
     */     
    public async getReportAgedPayablesByContact (xeroTenantId: string, contactId: string, date?: string, fromDate?: string, toDate?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: ReportWithRows;  }> {
        const localVarPath = this.basePath + '/Reports/AgedPayablesByContact';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getReportAgedPayablesByContact.');
        }

        // verify required parameter 'contactId' is not null or undefined
        if (contactId === null || contactId === undefined) {
            throw new Error('Required parameter contactId was null or undefined when calling getReportAgedPayablesByContact.');
        }

        if (contactId !== undefined) {
            localVarQueryParameters['contactId'] = ObjectSerializer.serialize(contactId, "string");
        }

        if (date !== undefined) {
            localVarQueryParameters['date'] = ObjectSerializer.serialize(date, "string");
        }

        if (fromDate !== undefined) {
            localVarQueryParameters['fromDate'] = ObjectSerializer.serialize(fromDate, "string");
        }

        if (toDate !== undefined) {
            localVarQueryParameters['toDate'] = ObjectSerializer.serialize(toDate, "string");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: ReportWithRows;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "ReportWithRows");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves report for aged receivables by contact
     * @param xeroTenantId Xero identifier for Tenant
     * @param contactId Unique identifier for a Contact
     * @param date The date of the Aged Receivables By Contact report
     * @param fromDate filter by the from date of the report e.g. 2021-02-01
     * @param toDate filter by the to date of the report e.g. 2021-02-28
     */     
    public async getReportAgedReceivablesByContact (xeroTenantId: string, contactId: string, date?: string, fromDate?: string, toDate?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: ReportWithRows;  }> {
        const localVarPath = this.basePath + '/Reports/AgedReceivablesByContact';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getReportAgedReceivablesByContact.');
        }

        // verify required parameter 'contactId' is not null or undefined
        if (contactId === null || contactId === undefined) {
            throw new Error('Required parameter contactId was null or undefined when calling getReportAgedReceivablesByContact.');
        }

        if (contactId !== undefined) {
            localVarQueryParameters['contactId'] = ObjectSerializer.serialize(contactId, "string");
        }

        if (date !== undefined) {
            localVarQueryParameters['date'] = ObjectSerializer.serialize(date, "string");
        }

        if (fromDate !== undefined) {
            localVarQueryParameters['fromDate'] = ObjectSerializer.serialize(fromDate, "string");
        }

        if (toDate !== undefined) {
            localVarQueryParameters['toDate'] = ObjectSerializer.serialize(toDate, "string");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: ReportWithRows;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "ReportWithRows");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves report for balancesheet
     * @param xeroTenantId Xero identifier for Tenant
     * @param date The date of the Balance Sheet report
     * @param periods The number of periods for the Balance Sheet report
     * @param timeframe The period size to compare to (MONTH, QUARTER, YEAR)
     * @param trackingOptionID1 The tracking option 1 for the Balance Sheet report
     * @param trackingOptionID2 The tracking option 2 for the Balance Sheet report
     * @param standardLayout The standard layout boolean for the Balance Sheet report
     * @param paymentsOnly return a cash basis for the Balance Sheet report
     */     
    public async getReportBalanceSheet (xeroTenantId: string, date?: string, periods?: number, timeframe?: 'MONTH' | 'QUARTER' | 'YEAR', trackingOptionID1?: string, trackingOptionID2?: string, standardLayout?: boolean, paymentsOnly?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: ReportWithRows;  }> {
        const localVarPath = this.basePath + '/Reports/BalanceSheet';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getReportBalanceSheet.');
        }

        if (date !== undefined) {
            localVarQueryParameters['date'] = ObjectSerializer.serialize(date, "string");
        }

        if (periods !== undefined) {
            localVarQueryParameters['periods'] = ObjectSerializer.serialize(periods, "number");
        }

        if (timeframe !== undefined) {
            localVarQueryParameters['timeframe'] = ObjectSerializer.serialize(timeframe, "'MONTH' | 'QUARTER' | 'YEAR'");
        }

        if (trackingOptionID1 !== undefined) {
            localVarQueryParameters['trackingOptionID1'] = ObjectSerializer.serialize(trackingOptionID1, "string");
        }

        if (trackingOptionID2 !== undefined) {
            localVarQueryParameters['trackingOptionID2'] = ObjectSerializer.serialize(trackingOptionID2, "string");
        }

        if (standardLayout !== undefined) {
            localVarQueryParameters['standardLayout'] = ObjectSerializer.serialize(standardLayout, "boolean");
        }

        if (paymentsOnly !== undefined) {
            localVarQueryParameters['paymentsOnly'] = ObjectSerializer.serialize(paymentsOnly, "boolean");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: ReportWithRows;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "ReportWithRows");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves report for bank summary
     * @param xeroTenantId Xero identifier for Tenant
     * @param fromDate filter by the from date of the report e.g. 2021-02-01
     * @param toDate filter by the to date of the report e.g. 2021-02-28
     */     
    public async getReportBankSummary (xeroTenantId: string, fromDate?: string, toDate?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: ReportWithRows;  }> {
        const localVarPath = this.basePath + '/Reports/BankSummary';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getReportBankSummary.');
        }

        if (fromDate !== undefined) {
            localVarQueryParameters['fromDate'] = ObjectSerializer.serialize(fromDate, "string");
        }

        if (toDate !== undefined) {
            localVarQueryParameters['toDate'] = ObjectSerializer.serialize(toDate, "string");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: ReportWithRows;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "ReportWithRows");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves report for budget summary
     * @param xeroTenantId Xero identifier for Tenant
     * @param date The date for the Bank Summary report e.g. 2018-03-31
     * @param periods The number of periods to compare (integer between 1 and 12)
     * @param timeframe The period size to compare to (1&#x3D;month, 3&#x3D;quarter, 12&#x3D;year)
     */     
    public async getReportBudgetSummary (xeroTenantId: string, date?: string, periods?: number, timeframe?: number, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: ReportWithRows;  }> {
        const localVarPath = this.basePath + '/Reports/BudgetSummary';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getReportBudgetSummary.');
        }

        if (date !== undefined) {
            localVarQueryParameters['date'] = ObjectSerializer.serialize(date, "string");
        }

        if (periods !== undefined) {
            localVarQueryParameters['periods'] = ObjectSerializer.serialize(periods, "number");
        }

        if (timeframe !== undefined) {
            localVarQueryParameters['timeframe'] = ObjectSerializer.serialize(timeframe, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: ReportWithRows;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "ReportWithRows");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves report for executive summary
     * @param xeroTenantId Xero identifier for Tenant
     * @param date The date for the Bank Summary report e.g. 2018-03-31
     */     
    public async getReportExecutiveSummary (xeroTenantId: string, date?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: ReportWithRows;  }> {
        const localVarPath = this.basePath + '/Reports/ExecutiveSummary';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getReportExecutiveSummary.');
        }

        if (date !== undefined) {
            localVarQueryParameters['date'] = ObjectSerializer.serialize(date, "string");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: ReportWithRows;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "ReportWithRows");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific report using a unique ReportID
     * @param xeroTenantId Xero identifier for Tenant
     * @param reportID Unique identifier for a Report
     */     
    public async getReportFromId (xeroTenantId: string, reportID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: ReportWithRows;  }> {
        const localVarPath = this.basePath + '/Reports/{ReportID}'
            .replace('{' + 'ReportID' + '}', encodeURIComponent(String(reportID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getReportFromId.');
        }

        // verify required parameter 'reportID' is not null or undefined
        if (reportID === null || reportID === undefined) {
            throw new Error('Required parameter reportID was null or undefined when calling getReportFromId.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: ReportWithRows;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "ReportWithRows");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves report for profit and loss
     * @param xeroTenantId Xero identifier for Tenant
     * @param fromDate filter by the from date of the report e.g. 2021-02-01
     * @param toDate filter by the to date of the report e.g. 2021-02-28
     * @param periods The number of periods to compare (integer between 1 and 12)
     * @param timeframe The period size to compare to (MONTH, QUARTER, YEAR)
     * @param trackingCategoryID The trackingCategory 1 for the ProfitAndLoss report
     * @param trackingCategoryID2 The trackingCategory 2 for the ProfitAndLoss report
     * @param trackingOptionID The tracking option 1 for the ProfitAndLoss report
     * @param trackingOptionID2 The tracking option 2 for the ProfitAndLoss report
     * @param standardLayout Return the standard layout for the ProfitAndLoss report
     * @param paymentsOnly Return cash only basis for the ProfitAndLoss report
     */     
    public async getReportProfitAndLoss (xeroTenantId: string, fromDate?: string, toDate?: string, periods?: number, timeframe?: 'MONTH' | 'QUARTER' | 'YEAR', trackingCategoryID?: string, trackingCategoryID2?: string, trackingOptionID?: string, trackingOptionID2?: string, standardLayout?: boolean, paymentsOnly?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: ReportWithRows;  }> {
        const localVarPath = this.basePath + '/Reports/ProfitAndLoss';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getReportProfitAndLoss.');
        }

        if (fromDate !== undefined) {
            localVarQueryParameters['fromDate'] = ObjectSerializer.serialize(fromDate, "string");
        }

        if (toDate !== undefined) {
            localVarQueryParameters['toDate'] = ObjectSerializer.serialize(toDate, "string");
        }

        if (periods !== undefined) {
            localVarQueryParameters['periods'] = ObjectSerializer.serialize(periods, "number");
        }

        if (timeframe !== undefined) {
            localVarQueryParameters['timeframe'] = ObjectSerializer.serialize(timeframe, "'MONTH' | 'QUARTER' | 'YEAR'");
        }

        if (trackingCategoryID !== undefined) {
            localVarQueryParameters['trackingCategoryID'] = ObjectSerializer.serialize(trackingCategoryID, "string");
        }

        if (trackingCategoryID2 !== undefined) {
            localVarQueryParameters['trackingCategoryID2'] = ObjectSerializer.serialize(trackingCategoryID2, "string");
        }

        if (trackingOptionID !== undefined) {
            localVarQueryParameters['trackingOptionID'] = ObjectSerializer.serialize(trackingOptionID, "string");
        }

        if (trackingOptionID2 !== undefined) {
            localVarQueryParameters['trackingOptionID2'] = ObjectSerializer.serialize(trackingOptionID2, "string");
        }

        if (standardLayout !== undefined) {
            localVarQueryParameters['standardLayout'] = ObjectSerializer.serialize(standardLayout, "boolean");
        }

        if (paymentsOnly !== undefined) {
            localVarQueryParameters['paymentsOnly'] = ObjectSerializer.serialize(paymentsOnly, "boolean");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: ReportWithRows;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "ReportWithRows");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieve reports for 1099
     * @param xeroTenantId Xero identifier for Tenant
     * @param reportYear The year of the 1099 report
     */     
    public async getReportTenNinetyNine (xeroTenantId: string, reportYear?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Reports;  }> {
        const localVarPath = this.basePath + '/Reports/TenNinetyNine';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getReportTenNinetyNine.');
        }

        if (reportYear !== undefined) {
            localVarQueryParameters['reportYear'] = ObjectSerializer.serialize(reportYear, "string");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Reports;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Reports");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves report for trial balance
     * @param xeroTenantId Xero identifier for Tenant
     * @param date The date for the Trial Balance report e.g. 2018-03-31
     * @param paymentsOnly Return cash only basis for the Trial Balance report
     */     
    public async getReportTrialBalance (xeroTenantId: string, date?: string, paymentsOnly?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: ReportWithRows;  }> {
        const localVarPath = this.basePath + '/Reports/TrialBalance';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getReportTrialBalance.');
        }

        if (date !== undefined) {
            localVarQueryParameters['date'] = ObjectSerializer.serialize(date, "string");
        }

        if (paymentsOnly !== undefined) {
            localVarQueryParameters['paymentsOnly'] = ObjectSerializer.serialize(paymentsOnly, "boolean");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: ReportWithRows;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "ReportWithRows");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a list of the organistaions unique reports that require a uuid to fetch
     * @param xeroTenantId Xero identifier for Tenant
     */     
    public async getReportsList (xeroTenantId: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: ReportWithRows;  }> {
        const localVarPath = this.basePath + '/Reports';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getReportsList.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: ReportWithRows;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "ReportWithRows");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific tax rate according to given TaxType code
     * @param xeroTenantId Xero identifier for Tenant
     * @param taxType A valid TaxType code
     */     
    public async getTaxRateByTaxType (xeroTenantId: string, taxType: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: TaxRates;  }> {
        const localVarPath = this.basePath + '/TaxRates/{TaxType}'
            .replace('{' + 'TaxType' + '}', encodeURIComponent(String(taxType)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getTaxRateByTaxType.');
        }

        // verify required parameter 'taxType' is not null or undefined
        if (taxType === null || taxType === undefined) {
            throw new Error('Required parameter taxType was null or undefined when calling getTaxRateByTaxType.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: TaxRates;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "TaxRates");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves tax rates
     * @param xeroTenantId Xero identifier for Tenant
     * @param where Filter by an any element
     * @param order Order by an any element
     */     
    public async getTaxRates (xeroTenantId: string, where?: string, order?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: TaxRates;  }> {
        const localVarPath = this.basePath + '/TaxRates';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getTaxRates.');
        }

        if (where !== undefined) {
            localVarQueryParameters['where'] = ObjectSerializer.serialize(where, "string");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: TaxRates;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "TaxRates");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves tracking categories and options
     * @param xeroTenantId Xero identifier for Tenant
     * @param where Filter by an any element
     * @param order Order by an any element
     * @param includeArchived e.g. includeArchived&#x3D;true - Categories and options with a status of ARCHIVED will be included in the response
     */     
    public async getTrackingCategories (xeroTenantId: string, where?: string, order?: string, includeArchived?: boolean, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: TrackingCategories;  }> {
        const localVarPath = this.basePath + '/TrackingCategories';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getTrackingCategories.');
        }

        if (where !== undefined) {
            localVarQueryParameters['where'] = ObjectSerializer.serialize(where, "string");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        if (includeArchived !== undefined) {
            localVarQueryParameters['includeArchived'] = ObjectSerializer.serialize(includeArchived, "boolean");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: TrackingCategories;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "TrackingCategories");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves specific tracking categories and options using a unique tracking category Id
     * @param xeroTenantId Xero identifier for Tenant
     * @param trackingCategoryID Unique identifier for a TrackingCategory
     */     
    public async getTrackingCategory (xeroTenantId: string, trackingCategoryID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: TrackingCategories;  }> {
        const localVarPath = this.basePath + '/TrackingCategories/{TrackingCategoryID}'
            .replace('{' + 'TrackingCategoryID' + '}', encodeURIComponent(String(trackingCategoryID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getTrackingCategory.');
        }

        // verify required parameter 'trackingCategoryID' is not null or undefined
        if (trackingCategoryID === null || trackingCategoryID === undefined) {
            throw new Error('Required parameter trackingCategoryID was null or undefined when calling getTrackingCategory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: TrackingCategories;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "TrackingCategories");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves a specific user
     * @param xeroTenantId Xero identifier for Tenant
     * @param userID Unique identifier for a User
     */     
    public async getUser (xeroTenantId: string, userID: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Users;  }> {
        const localVarPath = this.basePath + '/Users/{UserID}'
            .replace('{' + 'UserID' + '}', encodeURIComponent(String(userID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getUser.');
        }

        // verify required parameter 'userID' is not null or undefined
        if (userID === null || userID === undefined) {
            throw new Error('Required parameter userID was null or undefined when calling getUser.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Users;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Users");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Retrieves users
     * @param xeroTenantId Xero identifier for Tenant
     * @param ifModifiedSince Only records created or modified since this timestamp will be returned
     * @param where Filter by an any element
     * @param order Order by an any element
     */     
    public async getUsers (xeroTenantId: string, ifModifiedSince?: Date, where?: string, order?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Users;  }> {
        const localVarPath = this.basePath + '/Users';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling getUsers.');
        }

        if (where !== undefined) {
            localVarQueryParameters['where'] = ObjectSerializer.serialize(where, "string");
        }

        if (order !== undefined) {
            localVarQueryParameters['order'] = ObjectSerializer.serialize(order, "string");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['If-Modified-Since'] = ObjectSerializer.serialize(ifModifiedSince, "Date");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'GET',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: {},
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Users;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Users");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Sets the chart of accounts, the conversion date and conversion balances
     * @param xeroTenantId Xero identifier for Tenant
     * @param setup Object including an accounts array, a conversion balances array and a conversion date object in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async postSetup (xeroTenantId: string, setup: Setup, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: ImportSummaryObject;  }> {
        const localVarPath = this.basePath + '/Setup';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling postSetup.');
        }

        // verify required parameter 'setup' is not null or undefined
        if (setup === null || setup === undefined) {
            throw new Error('Required parameter setup was null or undefined when calling postSetup.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(setup, "Setup"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: ImportSummaryObject;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "ImportSummaryObject");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a chart of accounts
     * @param xeroTenantId Xero identifier for Tenant
     * @param accountID Unique identifier for Account object
     * @param accounts Request of type Accounts array with one Account
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateAccount (xeroTenantId: string, accountID: string, accounts: Accounts, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Accounts;  }> {
        const localVarPath = this.basePath + '/Accounts/{AccountID}'
            .replace('{' + 'AccountID' + '}', encodeURIComponent(String(accountID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateAccount.');
        }

        // verify required parameter 'accountID' is not null or undefined
        if (accountID === null || accountID === undefined) {
            throw new Error('Required parameter accountID was null or undefined when calling updateAccount.');
        }

        // verify required parameter 'accounts' is not null or undefined
        if (accounts === null || accounts === undefined) {
            throw new Error('Required parameter accounts was null or undefined when calling updateAccount.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(accounts, "Accounts"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Accounts;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Accounts");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates attachment on a specific account by filename
     * @param xeroTenantId Xero identifier for Tenant
     * @param accountID Unique identifier for Account object
     * @param fileName Name of the attachment
     * @param body Byte array of file in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateAccountAttachmentByFileName (xeroTenantId: string, accountID: string, fileName: string, body: fs.ReadStream | Readable | Buffer , idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/Accounts/{AccountID}/Attachments/{FileName}'
            .replace('{' + 'AccountID' + '}', encodeURIComponent(String(accountID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateAccountAttachmentByFileName.');
        }

        // verify required parameter 'accountID' is not null or undefined
        if (accountID === null || accountID === undefined) {
            throw new Error('Required parameter accountID was null or undefined when calling updateAccountAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling updateAccountAttachmentByFileName.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateAccountAttachmentByFileName.');
        }
        this.binaryHeaders = {'Accept': 'application/json'};
        (<any>Object).assign(localVarHeaderParams, this.binaryHeaders);
        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(body, "string"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
        }).then(() => {
            // Reads file stream as chunks so we can put it in body of request.
            // This collects the whole file into memory, which is why we do it _after_ authentication.
            return new Promise<any[]>((resolve, reject) => {
               	let bodyStream;
                bodyStream = Buffer.isBuffer(body) ? Readable.from(body) : body
                const fileContents: any[] = [];
                bodyStream.on('data', (chunk) => {
                    fileContents.push(chunk);
                });
                bodyStream.on('end', () => {
                    resolve(fileContents);
                });
                bodyStream.on('error', (err) => {
                    reject(err);
                })
            });
        }).then((fileContents) => {
            const file = Buffer.concat(fileContents);
            localVarRequestOptions.data = file;
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a single spent or received money transaction
     * @param xeroTenantId Xero identifier for Tenant
     * @param bankTransactionID Xero generated unique identifier for a bank transaction
     * @param bankTransactions 
     * @param unitdp e.g. unitdp&#x3D;4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateBankTransaction (xeroTenantId: string, bankTransactionID: string, bankTransactions: BankTransactions, unitdp?: number, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: BankTransactions;  }> {
        const localVarPath = this.basePath + '/BankTransactions/{BankTransactionID}'
            .replace('{' + 'BankTransactionID' + '}', encodeURIComponent(String(bankTransactionID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateBankTransaction.');
        }

        // verify required parameter 'bankTransactionID' is not null or undefined
        if (bankTransactionID === null || bankTransactionID === undefined) {
            throw new Error('Required parameter bankTransactionID was null or undefined when calling updateBankTransaction.');
        }

        // verify required parameter 'bankTransactions' is not null or undefined
        if (bankTransactions === null || bankTransactions === undefined) {
            throw new Error('Required parameter bankTransactions was null or undefined when calling updateBankTransaction.');
        }

        if (unitdp !== undefined) {
            localVarQueryParameters['unitdp'] = ObjectSerializer.serialize(unitdp, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(bankTransactions, "BankTransactions"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: BankTransactions;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "BankTransactions");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific attachment from a specific bank transaction by filename
     * @param xeroTenantId Xero identifier for Tenant
     * @param bankTransactionID Xero generated unique identifier for a bank transaction
     * @param fileName Name of the attachment
     * @param body Byte array of file in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateBankTransactionAttachmentByFileName (xeroTenantId: string, bankTransactionID: string, fileName: string, body: fs.ReadStream | Readable | Buffer , idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/BankTransactions/{BankTransactionID}/Attachments/{FileName}'
            .replace('{' + 'BankTransactionID' + '}', encodeURIComponent(String(bankTransactionID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateBankTransactionAttachmentByFileName.');
        }

        // verify required parameter 'bankTransactionID' is not null or undefined
        if (bankTransactionID === null || bankTransactionID === undefined) {
            throw new Error('Required parameter bankTransactionID was null or undefined when calling updateBankTransactionAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling updateBankTransactionAttachmentByFileName.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateBankTransactionAttachmentByFileName.');
        }
        this.binaryHeaders = {'Accept': 'application/json'};
        (<any>Object).assign(localVarHeaderParams, this.binaryHeaders);
        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(body, "string"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
        }).then(() => {
            // Reads file stream as chunks so we can put it in body of request.
            // This collects the whole file into memory, which is why we do it _after_ authentication.
            return new Promise<any[]>((resolve, reject) => {
               	let bodyStream;
                bodyStream = Buffer.isBuffer(body) ? Readable.from(body) : body
                const fileContents: any[] = [];
                bodyStream.on('data', (chunk) => {
                    fileContents.push(chunk);
                });
                bodyStream.on('end', () => {
                    resolve(fileContents);
                });
                bodyStream.on('error', (err) => {
                    reject(err);
                })
            });
        }).then((fileContents) => {
            const file = Buffer.concat(fileContents);
            localVarRequestOptions.data = file;
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @param xeroTenantId Xero identifier for Tenant
     * @param bankTransferID Xero generated unique identifier for a bank transfer
     * @param fileName Name of the attachment
     * @param body Byte array of file in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateBankTransferAttachmentByFileName (xeroTenantId: string, bankTransferID: string, fileName: string, body: fs.ReadStream | Readable | Buffer , idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/BankTransfers/{BankTransferID}/Attachments/{FileName}'
            .replace('{' + 'BankTransferID' + '}', encodeURIComponent(String(bankTransferID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateBankTransferAttachmentByFileName.');
        }

        // verify required parameter 'bankTransferID' is not null or undefined
        if (bankTransferID === null || bankTransferID === undefined) {
            throw new Error('Required parameter bankTransferID was null or undefined when calling updateBankTransferAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling updateBankTransferAttachmentByFileName.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateBankTransferAttachmentByFileName.');
        }
        this.binaryHeaders = {'Accept': 'application/json'};
        (<any>Object).assign(localVarHeaderParams, this.binaryHeaders);
        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(body, "string"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
        }).then(() => {
            // Reads file stream as chunks so we can put it in body of request.
            // This collects the whole file into memory, which is why we do it _after_ authentication.
            return new Promise<any[]>((resolve, reject) => {
               	let bodyStream;
                bodyStream = Buffer.isBuffer(body) ? Readable.from(body) : body
                const fileContents: any[] = [];
                bodyStream.on('data', (chunk) => {
                    fileContents.push(chunk);
                });
                bodyStream.on('end', () => {
                    resolve(fileContents);
                });
                bodyStream.on('error', (err) => {
                    reject(err);
                })
            });
        }).then((fileContents) => {
            const file = Buffer.concat(fileContents);
            localVarRequestOptions.data = file;
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific contact in a Xero organisation
     * @param xeroTenantId Xero identifier for Tenant
     * @param contactID Unique identifier for a Contact
     * @param contacts an array of Contacts containing single Contact object with properties to update
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateContact (xeroTenantId: string, contactID: string, contacts: Contacts, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Contacts;  }> {
        const localVarPath = this.basePath + '/Contacts/{ContactID}'
            .replace('{' + 'ContactID' + '}', encodeURIComponent(String(contactID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateContact.');
        }

        // verify required parameter 'contactID' is not null or undefined
        if (contactID === null || contactID === undefined) {
            throw new Error('Required parameter contactID was null or undefined when calling updateContact.');
        }

        // verify required parameter 'contacts' is not null or undefined
        if (contacts === null || contacts === undefined) {
            throw new Error('Required parameter contacts was null or undefined when calling updateContact.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(contacts, "Contacts"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Contacts;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Contacts");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @param xeroTenantId Xero identifier for Tenant
     * @param contactID Unique identifier for a Contact
     * @param fileName Name of the attachment
     * @param body Byte array of file in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateContactAttachmentByFileName (xeroTenantId: string, contactID: string, fileName: string, body: fs.ReadStream | Readable | Buffer , idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/Contacts/{ContactID}/Attachments/{FileName}'
            .replace('{' + 'ContactID' + '}', encodeURIComponent(String(contactID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateContactAttachmentByFileName.');
        }

        // verify required parameter 'contactID' is not null or undefined
        if (contactID === null || contactID === undefined) {
            throw new Error('Required parameter contactID was null or undefined when calling updateContactAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling updateContactAttachmentByFileName.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateContactAttachmentByFileName.');
        }
        this.binaryHeaders = {'Accept': 'application/json'};
        (<any>Object).assign(localVarHeaderParams, this.binaryHeaders);
        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(body, "string"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
        }).then(() => {
            // Reads file stream as chunks so we can put it in body of request.
            // This collects the whole file into memory, which is why we do it _after_ authentication.
            return new Promise<any[]>((resolve, reject) => {
               	let bodyStream;
                bodyStream = Buffer.isBuffer(body) ? Readable.from(body) : body
                const fileContents: any[] = [];
                bodyStream.on('data', (chunk) => {
                    fileContents.push(chunk);
                });
                bodyStream.on('end', () => {
                    resolve(fileContents);
                });
                bodyStream.on('error', (err) => {
                    reject(err);
                })
            });
        }).then((fileContents) => {
            const file = Buffer.concat(fileContents);
            localVarRequestOptions.data = file;
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific contact group
     * @param xeroTenantId Xero identifier for Tenant
     * @param contactGroupID Unique identifier for a Contact Group
     * @param contactGroups an array of Contact groups with Name of specific group to update
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateContactGroup (xeroTenantId: string, contactGroupID: string, contactGroups: ContactGroups, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: ContactGroups;  }> {
        const localVarPath = this.basePath + '/ContactGroups/{ContactGroupID}'
            .replace('{' + 'ContactGroupID' + '}', encodeURIComponent(String(contactGroupID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateContactGroup.');
        }

        // verify required parameter 'contactGroupID' is not null or undefined
        if (contactGroupID === null || contactGroupID === undefined) {
            throw new Error('Required parameter contactGroupID was null or undefined when calling updateContactGroup.');
        }

        // verify required parameter 'contactGroups' is not null or undefined
        if (contactGroups === null || contactGroups === undefined) {
            throw new Error('Required parameter contactGroups was null or undefined when calling updateContactGroup.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(contactGroups, "ContactGroups"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: ContactGroups;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "ContactGroups");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific credit note
     * @param xeroTenantId Xero identifier for Tenant
     * @param creditNoteID Unique identifier for a Credit Note
     * @param creditNotes an array of Credit Notes containing credit note details to update
     * @param unitdp e.g. unitdp&#x3D;4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateCreditNote (xeroTenantId: string, creditNoteID: string, creditNotes: CreditNotes, unitdp?: number, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: CreditNotes;  }> {
        const localVarPath = this.basePath + '/CreditNotes/{CreditNoteID}'
            .replace('{' + 'CreditNoteID' + '}', encodeURIComponent(String(creditNoteID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateCreditNote.');
        }

        // verify required parameter 'creditNoteID' is not null or undefined
        if (creditNoteID === null || creditNoteID === undefined) {
            throw new Error('Required parameter creditNoteID was null or undefined when calling updateCreditNote.');
        }

        // verify required parameter 'creditNotes' is not null or undefined
        if (creditNotes === null || creditNotes === undefined) {
            throw new Error('Required parameter creditNotes was null or undefined when calling updateCreditNote.');
        }

        if (unitdp !== undefined) {
            localVarQueryParameters['unitdp'] = ObjectSerializer.serialize(unitdp, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(creditNotes, "CreditNotes"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: CreditNotes;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "CreditNotes");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates attachments on a specific credit note by file name
     * @param xeroTenantId Xero identifier for Tenant
     * @param creditNoteID Unique identifier for a Credit Note
     * @param fileName Name of the attachment
     * @param body Byte array of file in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateCreditNoteAttachmentByFileName (xeroTenantId: string, creditNoteID: string, fileName: string, body: fs.ReadStream | Readable | Buffer , idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/CreditNotes/{CreditNoteID}/Attachments/{FileName}'
            .replace('{' + 'CreditNoteID' + '}', encodeURIComponent(String(creditNoteID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateCreditNoteAttachmentByFileName.');
        }

        // verify required parameter 'creditNoteID' is not null or undefined
        if (creditNoteID === null || creditNoteID === undefined) {
            throw new Error('Required parameter creditNoteID was null or undefined when calling updateCreditNoteAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling updateCreditNoteAttachmentByFileName.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateCreditNoteAttachmentByFileName.');
        }
        this.binaryHeaders = {'Accept': 'application/json'};
        (<any>Object).assign(localVarHeaderParams, this.binaryHeaders);
        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(body, "string"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
        }).then(() => {
            // Reads file stream as chunks so we can put it in body of request.
            // This collects the whole file into memory, which is why we do it _after_ authentication.
            return new Promise<any[]>((resolve, reject) => {
               	let bodyStream;
                bodyStream = Buffer.isBuffer(body) ? Readable.from(body) : body
                const fileContents: any[] = [];
                bodyStream.on('data', (chunk) => {
                    fileContents.push(chunk);
                });
                bodyStream.on('end', () => {
                    resolve(fileContents);
                });
                bodyStream.on('error', (err) => {
                    reject(err);
                })
            });
        }).then((fileContents) => {
            const file = Buffer.concat(fileContents);
            localVarRequestOptions.data = file;
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific expense claims
     * @param xeroTenantId Xero identifier for Tenant
     * @param expenseClaimID Unique identifier for a ExpenseClaim
     * @param expenseClaims 
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateExpenseClaim (xeroTenantId: string, expenseClaimID: string, expenseClaims: ExpenseClaims, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: ExpenseClaims;  }> {
        const localVarPath = this.basePath + '/ExpenseClaims/{ExpenseClaimID}'
            .replace('{' + 'ExpenseClaimID' + '}', encodeURIComponent(String(expenseClaimID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateExpenseClaim.');
        }

        // verify required parameter 'expenseClaimID' is not null or undefined
        if (expenseClaimID === null || expenseClaimID === undefined) {
            throw new Error('Required parameter expenseClaimID was null or undefined when calling updateExpenseClaim.');
        }

        // verify required parameter 'expenseClaims' is not null or undefined
        if (expenseClaims === null || expenseClaims === undefined) {
            throw new Error('Required parameter expenseClaims was null or undefined when calling updateExpenseClaim.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(expenseClaims, "ExpenseClaims"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: ExpenseClaims;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "ExpenseClaims");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific sales invoices or purchase bills
     * @param xeroTenantId Xero identifier for Tenant
     * @param invoiceID Unique identifier for an Invoice
     * @param invoices 
     * @param unitdp e.g. unitdp&#x3D;4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateInvoice (xeroTenantId: string, invoiceID: string, invoices: Invoices, unitdp?: number, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Invoices;  }> {
        const localVarPath = this.basePath + '/Invoices/{InvoiceID}'
            .replace('{' + 'InvoiceID' + '}', encodeURIComponent(String(invoiceID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateInvoice.');
        }

        // verify required parameter 'invoiceID' is not null or undefined
        if (invoiceID === null || invoiceID === undefined) {
            throw new Error('Required parameter invoiceID was null or undefined when calling updateInvoice.');
        }

        // verify required parameter 'invoices' is not null or undefined
        if (invoices === null || invoices === undefined) {
            throw new Error('Required parameter invoices was null or undefined when calling updateInvoice.');
        }

        if (unitdp !== undefined) {
            localVarQueryParameters['unitdp'] = ObjectSerializer.serialize(unitdp, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(invoices, "Invoices"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Invoices;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Invoices");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates an attachment from a specific invoices or purchase bill by filename
     * @param xeroTenantId Xero identifier for Tenant
     * @param invoiceID Unique identifier for an Invoice
     * @param fileName Name of the attachment
     * @param body Byte array of file in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateInvoiceAttachmentByFileName (xeroTenantId: string, invoiceID: string, fileName: string, body: fs.ReadStream | Readable | Buffer , idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/Invoices/{InvoiceID}/Attachments/{FileName}'
            .replace('{' + 'InvoiceID' + '}', encodeURIComponent(String(invoiceID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateInvoiceAttachmentByFileName.');
        }

        // verify required parameter 'invoiceID' is not null or undefined
        if (invoiceID === null || invoiceID === undefined) {
            throw new Error('Required parameter invoiceID was null or undefined when calling updateInvoiceAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling updateInvoiceAttachmentByFileName.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateInvoiceAttachmentByFileName.');
        }
        this.binaryHeaders = {'Accept': 'application/json'};
        (<any>Object).assign(localVarHeaderParams, this.binaryHeaders);
        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(body, "string"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
        }).then(() => {
            // Reads file stream as chunks so we can put it in body of request.
            // This collects the whole file into memory, which is why we do it _after_ authentication.
            return new Promise<any[]>((resolve, reject) => {
               	let bodyStream;
                bodyStream = Buffer.isBuffer(body) ? Readable.from(body) : body
                const fileContents: any[] = [];
                bodyStream.on('data', (chunk) => {
                    fileContents.push(chunk);
                });
                bodyStream.on('end', () => {
                    resolve(fileContents);
                });
                bodyStream.on('error', (err) => {
                    reject(err);
                })
            });
        }).then((fileContents) => {
            const file = Buffer.concat(fileContents);
            localVarRequestOptions.data = file;
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific item
     * @param xeroTenantId Xero identifier for Tenant
     * @param itemID Unique identifier for an Item
     * @param items 
     * @param unitdp e.g. unitdp&#x3D;4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateItem (xeroTenantId: string, itemID: string, items: Items, unitdp?: number, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Items;  }> {
        const localVarPath = this.basePath + '/Items/{ItemID}'
            .replace('{' + 'ItemID' + '}', encodeURIComponent(String(itemID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateItem.');
        }

        // verify required parameter 'itemID' is not null or undefined
        if (itemID === null || itemID === undefined) {
            throw new Error('Required parameter itemID was null or undefined when calling updateItem.');
        }

        // verify required parameter 'items' is not null or undefined
        if (items === null || items === undefined) {
            throw new Error('Required parameter items was null or undefined when calling updateItem.');
        }

        if (unitdp !== undefined) {
            localVarQueryParameters['unitdp'] = ObjectSerializer.serialize(unitdp, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(items, "Items"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Items;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Items");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific linked transactions (billable expenses)
     * @param xeroTenantId Xero identifier for Tenant
     * @param linkedTransactionID Unique identifier for a LinkedTransaction
     * @param linkedTransactions 
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateLinkedTransaction (xeroTenantId: string, linkedTransactionID: string, linkedTransactions: LinkedTransactions, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: LinkedTransactions;  }> {
        const localVarPath = this.basePath + '/LinkedTransactions/{LinkedTransactionID}'
            .replace('{' + 'LinkedTransactionID' + '}', encodeURIComponent(String(linkedTransactionID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateLinkedTransaction.');
        }

        // verify required parameter 'linkedTransactionID' is not null or undefined
        if (linkedTransactionID === null || linkedTransactionID === undefined) {
            throw new Error('Required parameter linkedTransactionID was null or undefined when calling updateLinkedTransaction.');
        }

        // verify required parameter 'linkedTransactions' is not null or undefined
        if (linkedTransactions === null || linkedTransactions === undefined) {
            throw new Error('Required parameter linkedTransactions was null or undefined when calling updateLinkedTransaction.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(linkedTransactions, "LinkedTransactions"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: LinkedTransactions;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "LinkedTransactions");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific manual journal
     * @param xeroTenantId Xero identifier for Tenant
     * @param manualJournalID Unique identifier for a ManualJournal
     * @param manualJournals 
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateManualJournal (xeroTenantId: string, manualJournalID: string, manualJournals: ManualJournals, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: ManualJournals;  }> {
        const localVarPath = this.basePath + '/ManualJournals/{ManualJournalID}'
            .replace('{' + 'ManualJournalID' + '}', encodeURIComponent(String(manualJournalID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateManualJournal.');
        }

        // verify required parameter 'manualJournalID' is not null or undefined
        if (manualJournalID === null || manualJournalID === undefined) {
            throw new Error('Required parameter manualJournalID was null or undefined when calling updateManualJournal.');
        }

        // verify required parameter 'manualJournals' is not null or undefined
        if (manualJournals === null || manualJournals === undefined) {
            throw new Error('Required parameter manualJournals was null or undefined when calling updateManualJournal.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(manualJournals, "ManualJournals"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: ManualJournals;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "ManualJournals");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific attachment from a specific manual journal by file name
     * @param xeroTenantId Xero identifier for Tenant
     * @param manualJournalID Unique identifier for a ManualJournal
     * @param fileName Name of the attachment
     * @param body Byte array of file in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateManualJournalAttachmentByFileName (xeroTenantId: string, manualJournalID: string, fileName: string, body: fs.ReadStream | Readable | Buffer , idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/ManualJournals/{ManualJournalID}/Attachments/{FileName}'
            .replace('{' + 'ManualJournalID' + '}', encodeURIComponent(String(manualJournalID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateManualJournalAttachmentByFileName.');
        }

        // verify required parameter 'manualJournalID' is not null or undefined
        if (manualJournalID === null || manualJournalID === undefined) {
            throw new Error('Required parameter manualJournalID was null or undefined when calling updateManualJournalAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling updateManualJournalAttachmentByFileName.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateManualJournalAttachmentByFileName.');
        }
        this.binaryHeaders = {'Accept': 'application/json'};
        (<any>Object).assign(localVarHeaderParams, this.binaryHeaders);
        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(body, "string"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
        }).then(() => {
            // Reads file stream as chunks so we can put it in body of request.
            // This collects the whole file into memory, which is why we do it _after_ authentication.
            return new Promise<any[]>((resolve, reject) => {
               	let bodyStream;
                bodyStream = Buffer.isBuffer(body) ? Readable.from(body) : body
                const fileContents: any[] = [];
                bodyStream.on('data', (chunk) => {
                    fileContents.push(chunk);
                });
                bodyStream.on('end', () => {
                    resolve(fileContents);
                });
                bodyStream.on('error', (err) => {
                    reject(err);
                })
            });
        }).then((fileContents) => {
            const file = Buffer.concat(fileContents);
            localVarRequestOptions.data = file;
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates or creates one or more spent or received money transaction
     * @param xeroTenantId Xero identifier for Tenant
     * @param bankTransactions 
     * @param summarizeErrors If false return 200 OK and mix of successfully created objects and any with validation errors
     * @param unitdp e.g. unitdp&#x3D;4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateOrCreateBankTransactions (xeroTenantId: string, bankTransactions: BankTransactions, summarizeErrors?: boolean, unitdp?: number, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: BankTransactions;  }> {
        const localVarPath = this.basePath + '/BankTransactions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateOrCreateBankTransactions.');
        }

        // verify required parameter 'bankTransactions' is not null or undefined
        if (bankTransactions === null || bankTransactions === undefined) {
            throw new Error('Required parameter bankTransactions was null or undefined when calling updateOrCreateBankTransactions.');
        }

        if (summarizeErrors !== undefined) {
            localVarQueryParameters['summarizeErrors'] = ObjectSerializer.serialize(summarizeErrors, "boolean");
        }

        if (unitdp !== undefined) {
            localVarQueryParameters['unitdp'] = ObjectSerializer.serialize(unitdp, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(bankTransactions, "BankTransactions"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: BankTransactions;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "BankTransactions");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates or creates one or more contacts in a Xero organisation
     * @param xeroTenantId Xero identifier for Tenant
     * @param contacts 
     * @param summarizeErrors If false return 200 OK and mix of successfully created objects and any with validation errors
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateOrCreateContacts (xeroTenantId: string, contacts: Contacts, summarizeErrors?: boolean, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Contacts;  }> {
        const localVarPath = this.basePath + '/Contacts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateOrCreateContacts.');
        }

        // verify required parameter 'contacts' is not null or undefined
        if (contacts === null || contacts === undefined) {
            throw new Error('Required parameter contacts was null or undefined when calling updateOrCreateContacts.');
        }

        if (summarizeErrors !== undefined) {
            localVarQueryParameters['summarizeErrors'] = ObjectSerializer.serialize(summarizeErrors, "boolean");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(contacts, "Contacts"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Contacts;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Contacts");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates or creates one or more credit notes
     * @param xeroTenantId Xero identifier for Tenant
     * @param creditNotes an array of Credit Notes with a single CreditNote object.
     * @param summarizeErrors If false return 200 OK and mix of successfully created objects and any with validation errors
     * @param unitdp e.g. unitdp&#x3D;4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateOrCreateCreditNotes (xeroTenantId: string, creditNotes: CreditNotes, summarizeErrors?: boolean, unitdp?: number, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: CreditNotes;  }> {
        const localVarPath = this.basePath + '/CreditNotes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateOrCreateCreditNotes.');
        }

        // verify required parameter 'creditNotes' is not null or undefined
        if (creditNotes === null || creditNotes === undefined) {
            throw new Error('Required parameter creditNotes was null or undefined when calling updateOrCreateCreditNotes.');
        }

        if (summarizeErrors !== undefined) {
            localVarQueryParameters['summarizeErrors'] = ObjectSerializer.serialize(summarizeErrors, "boolean");
        }

        if (unitdp !== undefined) {
            localVarQueryParameters['unitdp'] = ObjectSerializer.serialize(unitdp, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(creditNotes, "CreditNotes"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: CreditNotes;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "CreditNotes");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates a single new employees used in Xero payrun
     * @param xeroTenantId Xero identifier for Tenant
     * @param employees Employees with array of Employee object in body of request
     * @param summarizeErrors If false return 200 OK and mix of successfully created objects and any with validation errors
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateOrCreateEmployees (xeroTenantId: string, employees: Employees, summarizeErrors?: boolean, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Employees;  }> {
        const localVarPath = this.basePath + '/Employees';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateOrCreateEmployees.');
        }

        // verify required parameter 'employees' is not null or undefined
        if (employees === null || employees === undefined) {
            throw new Error('Required parameter employees was null or undefined when calling updateOrCreateEmployees.');
        }

        if (summarizeErrors !== undefined) {
            localVarQueryParameters['summarizeErrors'] = ObjectSerializer.serialize(summarizeErrors, "boolean");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(employees, "Employees"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Employees;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Employees");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates or creates one or more sales invoices or purchase bills
     * @param xeroTenantId Xero identifier for Tenant
     * @param invoices 
     * @param summarizeErrors If false return 200 OK and mix of successfully created objects and any with validation errors
     * @param unitdp e.g. unitdp&#x3D;4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateOrCreateInvoices (xeroTenantId: string, invoices: Invoices, summarizeErrors?: boolean, unitdp?: number, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Invoices;  }> {
        const localVarPath = this.basePath + '/Invoices';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateOrCreateInvoices.');
        }

        // verify required parameter 'invoices' is not null or undefined
        if (invoices === null || invoices === undefined) {
            throw new Error('Required parameter invoices was null or undefined when calling updateOrCreateInvoices.');
        }

        if (summarizeErrors !== undefined) {
            localVarQueryParameters['summarizeErrors'] = ObjectSerializer.serialize(summarizeErrors, "boolean");
        }

        if (unitdp !== undefined) {
            localVarQueryParameters['unitdp'] = ObjectSerializer.serialize(unitdp, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(invoices, "Invoices"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Invoices;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Invoices");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates or creates one or more items
     * @param xeroTenantId Xero identifier for Tenant
     * @param items 
     * @param summarizeErrors If false return 200 OK and mix of successfully created objects and any with validation errors
     * @param unitdp e.g. unitdp&#x3D;4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateOrCreateItems (xeroTenantId: string, items: Items, summarizeErrors?: boolean, unitdp?: number, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Items;  }> {
        const localVarPath = this.basePath + '/Items';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateOrCreateItems.');
        }

        // verify required parameter 'items' is not null or undefined
        if (items === null || items === undefined) {
            throw new Error('Required parameter items was null or undefined when calling updateOrCreateItems.');
        }

        if (summarizeErrors !== undefined) {
            localVarQueryParameters['summarizeErrors'] = ObjectSerializer.serialize(summarizeErrors, "boolean");
        }

        if (unitdp !== undefined) {
            localVarQueryParameters['unitdp'] = ObjectSerializer.serialize(unitdp, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(items, "Items"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Items;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Items");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates or creates a single manual journal
     * @param xeroTenantId Xero identifier for Tenant
     * @param manualJournals ManualJournals array with ManualJournal object in body of request
     * @param summarizeErrors If false return 200 OK and mix of successfully created objects and any with validation errors
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateOrCreateManualJournals (xeroTenantId: string, manualJournals: ManualJournals, summarizeErrors?: boolean, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: ManualJournals;  }> {
        const localVarPath = this.basePath + '/ManualJournals';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateOrCreateManualJournals.');
        }

        // verify required parameter 'manualJournals' is not null or undefined
        if (manualJournals === null || manualJournals === undefined) {
            throw new Error('Required parameter manualJournals was null or undefined when calling updateOrCreateManualJournals.');
        }

        if (summarizeErrors !== undefined) {
            localVarQueryParameters['summarizeErrors'] = ObjectSerializer.serialize(summarizeErrors, "boolean");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(manualJournals, "ManualJournals"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: ManualJournals;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "ManualJournals");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates or creates one or more purchase orders
     * @param xeroTenantId Xero identifier for Tenant
     * @param purchaseOrders 
     * @param summarizeErrors If false return 200 OK and mix of successfully created objects and any with validation errors
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateOrCreatePurchaseOrders (xeroTenantId: string, purchaseOrders: PurchaseOrders, summarizeErrors?: boolean, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: PurchaseOrders;  }> {
        const localVarPath = this.basePath + '/PurchaseOrders';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateOrCreatePurchaseOrders.');
        }

        // verify required parameter 'purchaseOrders' is not null or undefined
        if (purchaseOrders === null || purchaseOrders === undefined) {
            throw new Error('Required parameter purchaseOrders was null or undefined when calling updateOrCreatePurchaseOrders.');
        }

        if (summarizeErrors !== undefined) {
            localVarQueryParameters['summarizeErrors'] = ObjectSerializer.serialize(summarizeErrors, "boolean");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(purchaseOrders, "PurchaseOrders"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: PurchaseOrders;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "PurchaseOrders");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates or creates one or more quotes
     * @param xeroTenantId Xero identifier for Tenant
     * @param quotes 
     * @param summarizeErrors If false return 200 OK and mix of successfully created objects and any with validation errors
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateOrCreateQuotes (xeroTenantId: string, quotes: Quotes, summarizeErrors?: boolean, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Quotes;  }> {
        const localVarPath = this.basePath + '/Quotes';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateOrCreateQuotes.');
        }

        // verify required parameter 'quotes' is not null or undefined
        if (quotes === null || quotes === undefined) {
            throw new Error('Required parameter quotes was null or undefined when calling updateOrCreateQuotes.');
        }

        if (summarizeErrors !== undefined) {
            localVarQueryParameters['summarizeErrors'] = ObjectSerializer.serialize(summarizeErrors, "boolean");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(quotes, "Quotes"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Quotes;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Quotes");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Creates or deletes one or more repeating invoice templates
     * @param xeroTenantId Xero identifier for Tenant
     * @param repeatingInvoices RepeatingInvoices with an array of repeating invoice objects in body of request
     * @param summarizeErrors If false return 200 OK and mix of successfully created objects and any with validation errors
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateOrCreateRepeatingInvoices (xeroTenantId: string, repeatingInvoices: RepeatingInvoices, summarizeErrors?: boolean, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: RepeatingInvoices;  }> {
        const localVarPath = this.basePath + '/RepeatingInvoices';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateOrCreateRepeatingInvoices.');
        }

        // verify required parameter 'repeatingInvoices' is not null or undefined
        if (repeatingInvoices === null || repeatingInvoices === undefined) {
            throw new Error('Required parameter repeatingInvoices was null or undefined when calling updateOrCreateRepeatingInvoices.');
        }

        if (summarizeErrors !== undefined) {
            localVarQueryParameters['summarizeErrors'] = ObjectSerializer.serialize(summarizeErrors, "boolean");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(repeatingInvoices, "RepeatingInvoices"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: RepeatingInvoices;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "RepeatingInvoices");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific purchase order
     * @param xeroTenantId Xero identifier for Tenant
     * @param purchaseOrderID Unique identifier for an Purchase Order
     * @param purchaseOrders 
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updatePurchaseOrder (xeroTenantId: string, purchaseOrderID: string, purchaseOrders: PurchaseOrders, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: PurchaseOrders;  }> {
        const localVarPath = this.basePath + '/PurchaseOrders/{PurchaseOrderID}'
            .replace('{' + 'PurchaseOrderID' + '}', encodeURIComponent(String(purchaseOrderID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updatePurchaseOrder.');
        }

        // verify required parameter 'purchaseOrderID' is not null or undefined
        if (purchaseOrderID === null || purchaseOrderID === undefined) {
            throw new Error('Required parameter purchaseOrderID was null or undefined when calling updatePurchaseOrder.');
        }

        // verify required parameter 'purchaseOrders' is not null or undefined
        if (purchaseOrders === null || purchaseOrders === undefined) {
            throw new Error('Required parameter purchaseOrders was null or undefined when calling updatePurchaseOrder.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(purchaseOrders, "PurchaseOrders"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: PurchaseOrders;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "PurchaseOrders");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific attachment for a specific purchase order by filename
     * @param xeroTenantId Xero identifier for Tenant
     * @param purchaseOrderID Unique identifier for an Purchase Order
     * @param fileName Name of the attachment
     * @param body Byte array of file in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updatePurchaseOrderAttachmentByFileName (xeroTenantId: string, purchaseOrderID: string, fileName: string, body: fs.ReadStream | Readable | Buffer , idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/PurchaseOrders/{PurchaseOrderID}/Attachments/{FileName}'
            .replace('{' + 'PurchaseOrderID' + '}', encodeURIComponent(String(purchaseOrderID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updatePurchaseOrderAttachmentByFileName.');
        }

        // verify required parameter 'purchaseOrderID' is not null or undefined
        if (purchaseOrderID === null || purchaseOrderID === undefined) {
            throw new Error('Required parameter purchaseOrderID was null or undefined when calling updatePurchaseOrderAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling updatePurchaseOrderAttachmentByFileName.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updatePurchaseOrderAttachmentByFileName.');
        }
        this.binaryHeaders = {'Accept': 'application/json'};
        (<any>Object).assign(localVarHeaderParams, this.binaryHeaders);
        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(body, "string"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
        }).then(() => {
            // Reads file stream as chunks so we can put it in body of request.
            // This collects the whole file into memory, which is why we do it _after_ authentication.
            return new Promise<any[]>((resolve, reject) => {
               	let bodyStream;
                bodyStream = Buffer.isBuffer(body) ? Readable.from(body) : body
                const fileContents: any[] = [];
                bodyStream.on('data', (chunk) => {
                    fileContents.push(chunk);
                });
                bodyStream.on('end', () => {
                    resolve(fileContents);
                });
                bodyStream.on('error', (err) => {
                    reject(err);
                })
            });
        }).then((fileContents) => {
            const file = Buffer.concat(fileContents);
            localVarRequestOptions.data = file;
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific quote
     * @param xeroTenantId Xero identifier for Tenant
     * @param quoteID Unique identifier for an Quote
     * @param quotes 
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateQuote (xeroTenantId: string, quoteID: string, quotes: Quotes, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Quotes;  }> {
        const localVarPath = this.basePath + '/Quotes/{QuoteID}'
            .replace('{' + 'QuoteID' + '}', encodeURIComponent(String(quoteID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateQuote.');
        }

        // verify required parameter 'quoteID' is not null or undefined
        if (quoteID === null || quoteID === undefined) {
            throw new Error('Required parameter quoteID was null or undefined when calling updateQuote.');
        }

        // verify required parameter 'quotes' is not null or undefined
        if (quotes === null || quotes === undefined) {
            throw new Error('Required parameter quotes was null or undefined when calling updateQuote.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(quotes, "Quotes"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Quotes;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Quotes");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific attachment from a specific quote by filename
     * @param xeroTenantId Xero identifier for Tenant
     * @param quoteID Unique identifier for an Quote
     * @param fileName Name of the attachment
     * @param body Byte array of file in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateQuoteAttachmentByFileName (xeroTenantId: string, quoteID: string, fileName: string, body: fs.ReadStream | Readable | Buffer , idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/Quotes/{QuoteID}/Attachments/{FileName}'
            .replace('{' + 'QuoteID' + '}', encodeURIComponent(String(quoteID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateQuoteAttachmentByFileName.');
        }

        // verify required parameter 'quoteID' is not null or undefined
        if (quoteID === null || quoteID === undefined) {
            throw new Error('Required parameter quoteID was null or undefined when calling updateQuoteAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling updateQuoteAttachmentByFileName.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateQuoteAttachmentByFileName.');
        }
        this.binaryHeaders = {'Accept': 'application/json'};
        (<any>Object).assign(localVarHeaderParams, this.binaryHeaders);
        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(body, "string"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
        }).then(() => {
            // Reads file stream as chunks so we can put it in body of request.
            // This collects the whole file into memory, which is why we do it _after_ authentication.
            return new Promise<any[]>((resolve, reject) => {
               	let bodyStream;
                bodyStream = Buffer.isBuffer(body) ? Readable.from(body) : body
                const fileContents: any[] = [];
                bodyStream.on('data', (chunk) => {
                    fileContents.push(chunk);
                });
                bodyStream.on('end', () => {
                    resolve(fileContents);
                });
                bodyStream.on('error', (err) => {
                    reject(err);
                })
            });
        }).then((fileContents) => {
            const file = Buffer.concat(fileContents);
            localVarRequestOptions.data = file;
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific draft expense claim receipts
     * @param xeroTenantId Xero identifier for Tenant
     * @param receiptID Unique identifier for a Receipt
     * @param receipts 
     * @param unitdp e.g. unitdp&#x3D;4 – (Unit Decimal Places) You can opt in to use four decimal places for unit amounts
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateReceipt (xeroTenantId: string, receiptID: string, receipts: Receipts, unitdp?: number, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Receipts;  }> {
        const localVarPath = this.basePath + '/Receipts/{ReceiptID}'
            .replace('{' + 'ReceiptID' + '}', encodeURIComponent(String(receiptID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateReceipt.');
        }

        // verify required parameter 'receiptID' is not null or undefined
        if (receiptID === null || receiptID === undefined) {
            throw new Error('Required parameter receiptID was null or undefined when calling updateReceipt.');
        }

        // verify required parameter 'receipts' is not null or undefined
        if (receipts === null || receipts === undefined) {
            throw new Error('Required parameter receipts was null or undefined when calling updateReceipt.');
        }

        if (unitdp !== undefined) {
            localVarQueryParameters['unitdp'] = ObjectSerializer.serialize(unitdp, "number");
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(receipts, "Receipts"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: Receipts;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Receipts");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific attachment on a specific expense claim receipts by file name
     * @param xeroTenantId Xero identifier for Tenant
     * @param receiptID Unique identifier for a Receipt
     * @param fileName Name of the attachment
     * @param body Byte array of file in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateReceiptAttachmentByFileName (xeroTenantId: string, receiptID: string, fileName: string, body: fs.ReadStream | Readable | Buffer , idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/Receipts/{ReceiptID}/Attachments/{FileName}'
            .replace('{' + 'ReceiptID' + '}', encodeURIComponent(String(receiptID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateReceiptAttachmentByFileName.');
        }

        // verify required parameter 'receiptID' is not null or undefined
        if (receiptID === null || receiptID === undefined) {
            throw new Error('Required parameter receiptID was null or undefined when calling updateReceiptAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling updateReceiptAttachmentByFileName.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateReceiptAttachmentByFileName.');
        }
        this.binaryHeaders = {'Accept': 'application/json'};
        (<any>Object).assign(localVarHeaderParams, this.binaryHeaders);
        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(body, "string"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
        }).then(() => {
            // Reads file stream as chunks so we can put it in body of request.
            // This collects the whole file into memory, which is why we do it _after_ authentication.
            return new Promise<any[]>((resolve, reject) => {
               	let bodyStream;
                bodyStream = Buffer.isBuffer(body) ? Readable.from(body) : body
                const fileContents: any[] = [];
                bodyStream.on('data', (chunk) => {
                    fileContents.push(chunk);
                });
                bodyStream.on('end', () => {
                    resolve(fileContents);
                });
                bodyStream.on('error', (err) => {
                    reject(err);
                })
            });
        }).then((fileContents) => {
            const file = Buffer.concat(fileContents);
            localVarRequestOptions.data = file;
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Deletes a specific repeating invoice template
     * @param xeroTenantId Xero identifier for Tenant
     * @param repeatingInvoiceID Unique identifier for a Repeating Invoice
     * @param repeatingInvoices 
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateRepeatingInvoice (xeroTenantId: string, repeatingInvoiceID: string, repeatingInvoices: RepeatingInvoices, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: RepeatingInvoices;  }> {
        const localVarPath = this.basePath + '/RepeatingInvoices/{RepeatingInvoiceID}'
            .replace('{' + 'RepeatingInvoiceID' + '}', encodeURIComponent(String(repeatingInvoiceID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateRepeatingInvoice.');
        }

        // verify required parameter 'repeatingInvoiceID' is not null or undefined
        if (repeatingInvoiceID === null || repeatingInvoiceID === undefined) {
            throw new Error('Required parameter repeatingInvoiceID was null or undefined when calling updateRepeatingInvoice.');
        }

        // verify required parameter 'repeatingInvoices' is not null or undefined
        if (repeatingInvoices === null || repeatingInvoices === undefined) {
            throw new Error('Required parameter repeatingInvoices was null or undefined when calling updateRepeatingInvoice.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(repeatingInvoices, "RepeatingInvoices"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: RepeatingInvoices;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "RepeatingInvoices");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific attachment from a specific repeating invoices by file name
     * @param xeroTenantId Xero identifier for Tenant
     * @param repeatingInvoiceID Unique identifier for a Repeating Invoice
     * @param fileName Name of the attachment
     * @param body Byte array of file in body of request
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateRepeatingInvoiceAttachmentByFileName (xeroTenantId: string, repeatingInvoiceID: string, fileName: string, body: fs.ReadStream | Readable | Buffer , idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: Attachments;  }> {
        const localVarPath = this.basePath + '/RepeatingInvoices/{RepeatingInvoiceID}/Attachments/{FileName}'
            .replace('{' + 'RepeatingInvoiceID' + '}', encodeURIComponent(String(repeatingInvoiceID)))
            .replace('{' + 'FileName' + '}', encodeURIComponent(String(fileName)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateRepeatingInvoiceAttachmentByFileName.');
        }

        // verify required parameter 'repeatingInvoiceID' is not null or undefined
        if (repeatingInvoiceID === null || repeatingInvoiceID === undefined) {
            throw new Error('Required parameter repeatingInvoiceID was null or undefined when calling updateRepeatingInvoiceAttachmentByFileName.');
        }

        // verify required parameter 'fileName' is not null or undefined
        if (fileName === null || fileName === undefined) {
            throw new Error('Required parameter fileName was null or undefined when calling updateRepeatingInvoiceAttachmentByFileName.');
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling updateRepeatingInvoiceAttachmentByFileName.');
        }
        this.binaryHeaders = {'Accept': 'application/json'};
        (<any>Object).assign(localVarHeaderParams, this.binaryHeaders);
        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(body, "string"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
        }).then(() => {
            // Reads file stream as chunks so we can put it in body of request.
            // This collects the whole file into memory, which is why we do it _after_ authentication.
            return new Promise<any[]>((resolve, reject) => {
               	let bodyStream;
                bodyStream = Buffer.isBuffer(body) ? Readable.from(body) : body
                const fileContents: any[] = [];
                bodyStream.on('data', (chunk) => {
                    fileContents.push(chunk);
                });
                bodyStream.on('end', () => {
                    resolve(fileContents);
                });
                bodyStream.on('error', (err) => {
                    reject(err);
                })
            });
        }).then((fileContents) => {
            const file = Buffer.concat(fileContents);
            localVarRequestOptions.data = file;
            return new Promise<{ response: AxiosResponse; body: Attachments;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "Attachments");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates tax rates
     * @param xeroTenantId Xero identifier for Tenant
     * @param taxRates 
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateTaxRate (xeroTenantId: string, taxRates: TaxRates, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: TaxRates;  }> {
        const localVarPath = this.basePath + '/TaxRates';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateTaxRate.');
        }

        // verify required parameter 'taxRates' is not null or undefined
        if (taxRates === null || taxRates === undefined) {
            throw new Error('Required parameter taxRates was null or undefined when calling updateTaxRate.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(taxRates, "TaxRates"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: TaxRates;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "TaxRates");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific tracking category
     * @param xeroTenantId Xero identifier for Tenant
     * @param trackingCategoryID Unique identifier for a TrackingCategory
     * @param trackingCategory 
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateTrackingCategory (xeroTenantId: string, trackingCategoryID: string, trackingCategory: TrackingCategory, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: TrackingCategories;  }> {
        const localVarPath = this.basePath + '/TrackingCategories/{TrackingCategoryID}'
            .replace('{' + 'TrackingCategoryID' + '}', encodeURIComponent(String(trackingCategoryID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateTrackingCategory.');
        }

        // verify required parameter 'trackingCategoryID' is not null or undefined
        if (trackingCategoryID === null || trackingCategoryID === undefined) {
            throw new Error('Required parameter trackingCategoryID was null or undefined when calling updateTrackingCategory.');
        }

        // verify required parameter 'trackingCategory' is not null or undefined
        if (trackingCategory === null || trackingCategory === undefined) {
            throw new Error('Required parameter trackingCategory was null or undefined when calling updateTrackingCategory.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(trackingCategory, "TrackingCategory"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: TrackingCategories;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "TrackingCategories");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
    /**
     * 
     * @summary Updates a specific option for a specific tracking category
     * @param xeroTenantId Xero identifier for Tenant
     * @param trackingCategoryID Unique identifier for a TrackingCategory
     * @param trackingOptionID Unique identifier for a Tracking Option
     * @param trackingOption 
     * @param idempotencyKey This allows you to safely retry requests without the risk of duplicate processing. 128 character max.
     */     
    public async updateTrackingOptions (xeroTenantId: string, trackingCategoryID: string, trackingOptionID: string, trackingOption: TrackingOption, idempotencyKey?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: AxiosResponse; body: TrackingOptions;  }> {
        const localVarPath = this.basePath + '/TrackingCategories/{TrackingCategoryID}/Options/{TrackingOptionID}'
            .replace('{' + 'TrackingCategoryID' + '}', encodeURIComponent(String(trackingCategoryID)))
            .replace('{' + 'TrackingOptionID' + '}', encodeURIComponent(String(trackingOptionID)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let localVarFormParams: any = {};
        let acceptHeadersFromSpec = [
                "application/json"
            ];
        const isBufferType = acceptHeadersFromSpec.includes("application/pdf")|| acceptHeadersFromSpec.includes("application/octet-stream") || acceptHeadersFromSpec.includes("application/jpg");
		const responseTypeOption = isBufferType ? "arraybuffer" : "json";

        // verify required parameter 'xeroTenantId' is not null or undefined
        if (xeroTenantId === null || xeroTenantId === undefined) {
            throw new Error('Required parameter xeroTenantId was null or undefined when calling updateTrackingOptions.');
        }

        // verify required parameter 'trackingCategoryID' is not null or undefined
        if (trackingCategoryID === null || trackingCategoryID === undefined) {
            throw new Error('Required parameter trackingCategoryID was null or undefined when calling updateTrackingOptions.');
        }

        // verify required parameter 'trackingOptionID' is not null or undefined
        if (trackingOptionID === null || trackingOptionID === undefined) {
            throw new Error('Required parameter trackingOptionID was null or undefined when calling updateTrackingOptions.');
        }

        // verify required parameter 'trackingOption' is not null or undefined
        if (trackingOption === null || trackingOption === undefined) {
            throw new Error('Required parameter trackingOption was null or undefined when calling updateTrackingOptions.');
        }

        localVarHeaderParams['xero-tenant-id'] = ObjectSerializer.serialize(xeroTenantId, "string");
        localVarHeaderParams['Idempotency-Key'] = ObjectSerializer.serialize(idempotencyKey, "string");
        localVarHeaderParams['Accept'] = acceptHeadersFromSpec.join();
        (<any>Object).assign(localVarHeaderParams, options.headers);
        let localVarUseFormData = false;

        let localVarRequestOptions: AxiosRequestConfig = {
            method: 'POST',
            params: localVarQueryParameters,
            headers: localVarHeaderParams,
            url: localVarPath,
            responseType: responseTypeOption,
            data: ObjectSerializer.serialize(trackingOption, "TrackingOption"),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.OAuth2.applyToRequest(localVarRequestOptions));

        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'Content-Type': 'multipart/form-data' };
                } else {
                    localVarRequestOptions.data = localVarFormParams;
                    localVarRequestOptions.headers = { ...localVarRequestOptions.headers, 'content-type': 'application/x-www-form-urlencoded' };
                }
            }
            return new Promise<{ response: AxiosResponse; body: TrackingOptions;  }>(async (resolve, reject) => {
            let body = null
            try {
                const response = await axios(localVarRequestOptions)
                         body = ObjectSerializer.deserialize(response.data, "TrackingOptions");
                        if (response.status && response.status >= 200 && response.status <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                }
                catch(error) {
                     const errorResponse = new ApiError(error)
					 reject(JSON.stringify(errorResponse.generateError()))
                }
            });
        });
    }
}
